diff --git a/squashfs-tools/action.c b/squashfs-tools/action.c
index 182487b..e418643 100644
--- a/squashfs-tools/action.c
+++ b/squashfs-tools/action.c
@@ -39,6 +39,10 @@
 #include <errno.h>
 #include <ctype.h>
 
+#ifndef FNM_EXTMATCH /* glibc extension */
+	#define FNM_EXTMATCH 0
+#endif
+
 #include "squashfs_fs.h"
 #include "mksquashfs.h"
 #include "action.h"
@@ -105,7 +109,7 @@ extern char *pathname(struct dir_ent *);
  * parsing.
  *
  * Lines can be split across multiple lines using "\".
- * 
+ *
  * Blank lines and comment lines indicated by # are supported.
  */
 static int read_file(char *filename, char *type, int (parse_line)(char *))
@@ -168,7 +172,7 @@ static int read_file(char *filename, char *type, int (parse_line)(char *))
 				break;
 			else
 				total --;
-		}	
+		}
 
 		if(err == NULL) {
 			if(ferror(fd)) {
@@ -484,7 +488,7 @@ skip_args:
 	if (test->parse_args) {
 		int res = test->parse_args(test, &expr->atom);
 
-		if (res == 0)		
+		if (res == 0)
 			goto failed;
 	}
 
@@ -545,7 +549,7 @@ static struct expr *parse_expr(int subexp)
 			}
 			break;
 		}
-		
+
 		if (op != TOK_AND && op != TOK_OR) {
 			free_parse_tree(expr);
 			SYNTAX_ERROR("Unexpected token \"%s\", expected "
@@ -664,7 +668,7 @@ skip_args:
 						TOK_TO_STR(token, string));
 		goto failed;
 	}
-	
+
 	parsing_action = action;
 	expr = parse_expr(0);
 
@@ -711,7 +715,7 @@ skip_args:
 		spec_count = other_count ++;
 		spec_list = &other_spec;
 	}
-	
+
 	*spec_list = realloc(*spec_list, (spec_count + 1) *
 					sizeof(struct action));
 	if (*spec_list == NULL)
@@ -769,7 +773,7 @@ static char *_expr_log(char *string, int cmnd)
 	}
 
 	/* if string is empty append '\0' */
-	size = strlen(string) ? : 1; 
+	size = strlen(string) ? : 1;
 
 	if(alloc_size - cur_size < size) {
 		/* buffer too small, expand */
@@ -781,7 +785,7 @@ static char *_expr_log(char *string, int cmnd)
 	}
 
 	memcpy(expr_msg + cur_size, string, size);
-	cur_size += size; 
+	cur_size += size;
 
 	return expr_msg;
 }
@@ -935,7 +939,7 @@ static int eval_expr_top(struct action *action, struct action_data *action_data)
  *	action(arg1,arg2)@expr(arg1,arg2)....
  *
  * Actions can be split across multiple lines using "\".
- * 
+ *
  * Blank lines and comment lines indicated by # are supported.
  */
 static int parse_action_true(char *s)
@@ -1099,7 +1103,7 @@ void *get_frag_action(void *fragment)
 
 	if (fragment == &tail_fragment)
 		action = &fragment_spec[0] - 1;
-	else 
+	else
 		action = fragment - offsetof(struct action, data);
 
 	if (++action == spec_list_end)
@@ -1449,9 +1453,9 @@ parse_operation:
 				"'%c'\n", *arg);
 			goto failed;
 		}
-	
+
 		arg ++;
-	
+
 		/* Parse PERMS */
 		if (*arg == 'u' || *arg == 'g' || *arg == 'o') {
 	 		/* PERMS = [ugo] */
@@ -1490,11 +1494,11 @@ parse_operation:
 								"'%c'\n", *arg);
 					goto failed;
 				}
-	
+
 				arg ++;
 			}
 		}
-	
+
 perms_parsed:
 		mode_data = malloc(sizeof(*mode_data));
 		if (mode_data == NULL)
@@ -1694,7 +1698,7 @@ int eval_empty_actions(struct dir_info *root, struct dir_ent *dir_ent)
 		if ((data->val == EMPTY_EXCLUDED && !dir->excluded) ||
 				(data->val == EMPTY_SOURCE && dir->excluded))
 			continue;
-		
+
 		match = eval_expr_top(&empty_spec[i], &action_data);
 	}
 
@@ -2463,7 +2467,7 @@ static int parse_range_args(struct test_entry *test, struct atom *atom)
 			"expected\n");
 		return 0;
 	}
- 
+
 	res = parse_number(atom->argv[1], &end, &type, &error);
 	if (res == 0) {
 		TEST_SYNTAX_ERROR(test, 1, "%s\n", error);
@@ -2475,7 +2479,7 @@ static int parse_range_args(struct test_entry *test, struct atom *atom)
 			"expected\n");
 		return 0;
 	}
- 
+
 	range = malloc(sizeof(*range));
 	if (range == NULL)
 		MEM_ERROR();
@@ -2523,19 +2527,19 @@ static int NAME##_fn(struct atom *atom, struct action_data *action_data) \
 	} \
 	\
 	return match; \
-	})	
+	})
 
 
 /*
  * Generic test code macro testing VAR for range [x, y] (value between x and y
  * inclusive).
- */	
+ */
 #define TEST_VAR_RANGE_FN(NAME, MATCH, VAR) TEST_FN(NAME##_range, MATCH, \
 	{ \
 	struct test_range_args *range = atom->data; \
 	\
 	return range->start <= VAR && VAR <= range->end; \
-	})	
+	})
 
 
 /*
@@ -2606,7 +2610,7 @@ static char *get_start(char *s, int n)
 
 	return s;
 }
-	
+
 
 static int subpathname_fn(struct atom *atom, struct action_data *data)
 {
@@ -2770,7 +2774,7 @@ failed:
 		"'c', 'b', 'l', 's' or 'p'\n");
 	return 0;
 }
-	
+
 
 static int type_fn(struct atom *atom, struct action_data *action_data)
 {
@@ -2883,7 +2887,7 @@ static int file_fn(struct atom *atom, struct action_data *action_data)
 
 	if (res == -1)
 		BAD_ERROR("file_fn waitpid failed\n");
- 
+
 	if (!WIFEXITED(status) || WEXITSTATUS(status) != 0)
 		BAD_ERROR("file_fn file returned error\n");
 
@@ -2952,14 +2956,14 @@ static int exec_fn(struct atom *atom, struct action_data *action_data)
 	}
 
 	/*
-	 * Parent process. 
+	 * Parent process.
  	 */
 
 	res = waitpid(child,  &status, 0);
 
 	if (res == -1)
 		BAD_ERROR("exec_fn waitpid failed\n");
- 
+
 	return WIFEXITED(status) ? WEXITSTATUS(status) == 0 : 0;
 }
 
@@ -3299,7 +3303,7 @@ static int eval_fn(struct atom *atom, struct action_data *action_data)
 				path ++;
 			if(path[0] == '\0')
 				dir_ent = dir_ent->our_dir->dir_ent;
-			else 
+			else
 				dir_ent = follow_path(dir_ent->our_dir, path);
 		} else if(!file_type_match(buf->st_mode, ACTION_DIR))
 			dir_ent = NULL;
@@ -3399,7 +3403,7 @@ static int parse_perm_args(struct test_entry *test, struct atom *atom)
 	perm_data->mode = mode;
 
 	atom->data = perm_data;
-	
+
 finish:
 	while(head) {
 		struct mode_data *tmp = head;
diff --git a/squashfs-tools/info.c b/squashfs-tools/info.c
index 49f0c72..7460bd1 100644
--- a/squashfs-tools/info.c
+++ b/squashfs-tools/info.c
@@ -150,6 +150,7 @@ static void *info_thrd(void *arg)
 	sigemptyset(&sigmask);
 	sigaddset(&sigmask, SIGQUIT);
 	sigaddset(&sigmask, SIGHUP);
+	sigaddset(&sigmask, SIGALRM);
 
 	while(1) {
 		sig = wait_for_signal(&sigmask, &waiting);
@@ -160,8 +161,12 @@ static void *info_thrd(void *arg)
 			/* set one second interval period, if ^\ received
 			   within then, dump queue and cache status */
 			waiting = 1;
-		} else
+			alarm(1);
+		} else if (sig == SIGQUIT) {
 			dump_state();
+		} else if (sig == SIGALRM) {
+			waiting = 0;
+		}
 	}
 
 	return NULL;
diff --git a/squashfs-tools/mksquashfs.c b/squashfs-tools/mksquashfs.c
index 3429aac..1349c60 100644
--- a/squashfs-tools/mksquashfs.c
+++ b/squashfs-tools/mksquashfs.c
@@ -35,7 +35,6 @@
 #include <stddef.h>
 #include <sys/types.h>
 #include <sys/stat.h>
-#include <sys/sysmacros.h>
 #include <fcntl.h>
 #include <errno.h>
 #include <dirent.h>
@@ -50,7 +49,12 @@
 #include <limits.h>
 #include <ctype.h>
 
+#ifndef FNM_EXTMATCH /* glibc extension */
+	#define FNM_EXTMATCH 0
+#endif
+
 #ifdef __linux__
+#include <sys/sysmacros.h>
 #include <sys/sysinfo.h>
 #include <sched.h>
 #else
@@ -422,7 +426,7 @@ int shift_overflow(int a, int shift)
 	return (INT_MAX >> shift) < a;
 }
 
- 
+
 int multiply_overflow(int a, int multiplier)
 {
 	return (INT_MAX / multiplier) < a;
@@ -703,7 +707,7 @@ static long long write_inodes()
 		c_byte = mangle(inode_table + inode_bytes + BLOCK_OFFSET, datap,
 			avail_bytes, SQUASHFS_METADATA_SIZE, noI, 0);
 		TRACE("Inode block @ 0x%x, size %d\n", inode_bytes, c_byte);
-		SQUASHFS_SWAP_SHORTS(&c_byte, inode_table + inode_bytes, 1); 
+		SQUASHFS_SWAP_SHORTS(&c_byte, inode_table + inode_bytes, 1);
 		inode_bytes += SQUASHFS_COMPRESSED_SIZE(c_byte) + BLOCK_OFFSET;
 		total_inode_bytes += avail_bytes + BLOCK_OFFSET;
 		datap += avail_bytes;
@@ -928,7 +932,7 @@ static inline unsigned int get_parent_no(struct dir_info *dir)
 	return dir->depth ? get_inode_no(dir->dir_ent->inode) : inode_no;
 }
 
-	
+
 static inline time_t get_time(time_t time)
 {
 	if(all_time_opt) {
@@ -1228,7 +1232,7 @@ static void add_dir(squashfs_inode inode, unsigned int inode_number, char *name,
 			MEM_ERROR();
 
 		dir->p = (dir->p - dir->buff) + buff;
-		if(dir->entry_count_p) 
+		if(dir->entry_count_p)
 			dir->entry_count_p = (dir->entry_count_p - dir->buff +
 			buff);
 		dir->index_count_p = dir->index_count_p - dir->buff + buff;
@@ -1625,7 +1629,7 @@ static void unlock_fragments()
 	 */
 	while(!queue_empty(locked_fragment)) {
 		write_buffer = queue_get(locked_fragment);
-		frg = write_buffer->block;	
+		frg = write_buffer->block;
 		size = SQUASHFS_COMPRESSED_SIZE_BLOCK(fragment_table[frg].size);
 		fragment_table[frg].start_block = bytes;
 		write_buffer->block = bytes;
@@ -1745,7 +1749,7 @@ long long generic_write_table(long long length, void *buffer, int length2,
 	int compressed_size, i, list_size = meta_blocks * sizeof(long long);
 	unsigned short c_byte;
 	char cbuffer[(SQUASHFS_METADATA_SIZE << 2) + 2];
-	
+
 #ifdef SQUASHFS_TRACE
 	long long obytes = bytes;
 	long long olength = length;
@@ -1779,7 +1783,7 @@ long long generic_write_table(long long length, void *buffer, int length2,
 		bytes += length2;
 		total_bytes += length2;
 	}
-		
+
 	SQUASHFS_INSWAP_LONG_LONGS(list, meta_blocks);
 	write_destination(fd, bytes, list_size, list);
 	bytes += list_size;
@@ -1873,7 +1877,7 @@ static unsigned short get_checksum_disk(long long start, long long l,
 			cache_block_put(write_buffer);
 		} else {
 			void *data = read_from_disk(start, bytes);
-			if(data == NULL) {	
+			if(data == NULL) {
 				ERROR("Failed to checksum data from output"
 					" filesystem\n");
 				BAD_ERROR("Output filesystem corrupted?\n");
@@ -2581,7 +2585,7 @@ static void *deflator(void *arg)
 	while(1) {
 		struct file_buffer *file_buffer = queue_get(to_deflate);
 
-		if(sparse_files && all_zero(file_buffer)) { 
+		if(sparse_files && all_zero(file_buffer)) {
 			file_buffer->c_byte = 0;
 			seq_queue_put(to_main, file_buffer);
 		} else {
@@ -3884,7 +3888,7 @@ static struct dir_info *dir_scan1(char *filename, char *subpath,
 
 		if(exclude_actions()) {
 			subpath = subpathname(dir_ent);
-			
+
 			if(eval_exclude_actions(dir_name, filename, subpath,
 							&buf, depth, dir_ent)) {
 				add_excluded(dir);
@@ -3959,7 +3963,7 @@ static struct dir_ent *scan2_readdir(struct dir_info *dir, struct dir_ent *dir_e
 
 	for(; dir_ent && dir_ent->inode->root_entry; dir_ent = dir_ent->next);
 
-	return dir_ent;	
+	return dir_ent;
 }
 
 
@@ -3968,7 +3972,7 @@ static void dir_scan2(struct dir_info *dir, struct pseudo *pseudo)
 	struct dir_ent *dirent = NULL;
 	struct pseudo_entry *pseudo_ent;
 	struct stat buf;
-	
+
 	while((dirent = scan2_readdir(dir, dirent)) != NULL) {
 		struct inode_info *inode_info = dirent->inode;
 		struct stat *buf = &inode_info->buf;
@@ -3981,7 +3985,7 @@ static void dir_scan2(struct dir_info *dir, struct pseudo *pseudo)
 
 		if(pseudo_override && global_gid_opt)
 			buf->st_gid = global_gid;
-			
+
 		if((buf->st_mode & S_IFMT) == S_IFDIR)
 			dir_scan2(dirent->dir, pseudo_subdir(name, pseudo));
 	}
@@ -4154,7 +4158,7 @@ void free_dir(struct dir_info *dir)
 	free(dir->subpath);
 	free(dir);
 }
-	
+
 
 static void dir_scan4(struct dir_info *dir, int symlink)
 {
@@ -4192,7 +4196,7 @@ static void dir_scan4(struct dir_info *dir, int symlink)
 				prev->next = dir_ent;
 			else
 				dir->list = dir_ent;
-			
+
 			/* free it */
 			free_dir_entry(tmp);
 
@@ -4243,7 +4247,7 @@ static void dir_scan5(struct dir_info *dir)
 					prev->next = dir_ent;
 				else
 					dir->list = dir_ent;
-			
+
 				/* free it */
 				free_dir_entry(tmp);
 
@@ -4274,7 +4278,7 @@ static void dir_scan5(struct dir_info *dir)
  * is not ideal for arrays (as it needs an additonal n storage locations
  * as sorting is not done in place), but it is ideal for linked lists because
  * it doesn't require any extra storage,
- */ 
+ */
 SORT(sort_directory, dir_ent, name, next);
 
 static void dir_scan6(struct dir_info *dir)
@@ -4333,7 +4337,7 @@ static struct dir_ent *scan7_readdir(struct directory *dir, struct dir_info *dir
 		add_dir(dir_ent->inode->inode, dir_ent->inode->inode_number,
 			dir_ent->name, dir_ent->inode->type, dir);
 
-	return dir_ent;	
+	return dir_ent;
 }
 
 
@@ -4352,9 +4356,9 @@ static void dir_scan7(squashfs_inode *inode, struct dir_info *dir_info)
 	struct directory dir;
 	struct dir_ent *dir_ent = NULL;
 	struct file_info *file;
-	
+
 	scan7_init_dir(&dir);
-	
+
 	while((dir_ent = scan7_readdir(&dir, dir_info, dir_ent)) != NULL) {
 		struct stat *buf = &dir_ent->inode->buf;
 
@@ -4495,7 +4499,7 @@ static void dir_scan7(squashfs_inode *inode, struct dir_info *dir_info)
 			}
 			hardlnk_count ++;
 		}
-		
+
 		add_dir(*inode, get_inode_no(dir_ent->inode), dir_ent->name,
 			squashfs_type, &dir);
 	}
@@ -5231,6 +5235,7 @@ static void initialise_threads(int readq, int fragq, int bwriteq, int fwriteq,
 	sigemptyset(&sigmask);
 	sigaddset(&sigmask, SIGQUIT);
 	sigaddset(&sigmask, SIGHUP);
+	sigaddset(&sigmask, SIGALRM);
 	if(pthread_sigmask(SIG_BLOCK, &sigmask, NULL) != 0)
 		BAD_ERROR("Failed to set signal mask in intialise_threads\n");
 
@@ -5495,10 +5500,10 @@ static void add_exclude(char *target)
 	if(target[0] == '/' || strncmp(target, "./", 2) == 0 ||
 			strncmp(target, "../", 3) == 0)
 		BAD_ERROR("/, ./ and ../ prefixed excludes not supported with "
-			"-wildcards or -regex options\n");	
+			"-wildcards or -regex options\n");
 	else if(strncmp(target, "... ", 4) == 0)
 		stickypath = add_path(stickypath, target + 4, target + 4);
-	else	
+	else
 		path = add_path(path, target, target);
 }
 
@@ -5553,7 +5558,7 @@ static int excluded_match(char *name, struct pathname *path, struct pathnames **
 int excluded(char *name, struct pathnames *paths, struct pathnames **new)
 {
 	int n;
-		
+
 	if(stickypath && excluded_match(name, stickypath, new))
 		return TRUE;
 
@@ -5680,7 +5685,7 @@ static void write_recovery_data(struct squashfs_super_block *sBlk)
 	if(recoverfd == -1)
 		BAD_ERROR("Failed to create recovery file, because %s.  "
 			"Aborting\n", strerror(errno));
-		
+
 	if(write_bytes(recoverfd, header, RECOVER_ID_SIZE) == -1)
 		BAD_ERROR("Failed to write recovery file, because %s\n",
 			strerror(errno));
@@ -5700,7 +5705,7 @@ static void write_recovery_data(struct squashfs_super_block *sBlk)
 				strerror(errno));
 
 	free(metadata);
-	
+
 	printf("Recovery file \"%s\" written\n", recovery_file);
 	printf("If Mksquashfs aborts abnormally (i.e. power failure), run\n");
 	printf("mksquashfs - %s -recover %s\n", destination_file,
@@ -5791,7 +5796,7 @@ static void read_recovery_data(char *recovery_file, char *destination_file)
 
 	printf("Successfully wrote recovery file \"%s\".  Exiting\n",
 		recovery_file);
-	
+
 	exit(0);
 }
 
@@ -5820,7 +5825,7 @@ static void write_filesystem_tables(struct squashfs_super_block *sBlk)
 
 	sBlk->compression = comp->id;
 
-	SQUASHFS_INSWAP_SUPER_BLOCK(sBlk); 
+	SQUASHFS_INSWAP_SUPER_BLOCK(sBlk);
 	write_destination(fd, SQUASHFS_START, sizeof(*sBlk), sBlk);
 
 	total_bytes += total_inode_bytes + total_directory_bytes +
@@ -5925,7 +5930,7 @@ static int parse_number(char *start, int *res, int size)
 
 	if(!_parse_numberll(start, &number, size, 10))
 		return 0;
-	
+
 	/* check if long result will overflow signed int */
 	if(number > INT_MAX)
 		return 0;
@@ -5941,7 +5946,7 @@ static int parse_number_unsigned(char *start, unsigned int *res, int size)
 
 	if(!_parse_numberll(start, &number, size, 10))
 		return 0;
-	
+
 	/* check if long result will overflow unsigned int */
 	if(number > UINT_MAX)
 		return 0;
@@ -6029,7 +6034,7 @@ static void check_usable_phys_mem(int total_mem)
 	int mem = get_physical_memory();
 
 	mem = (mem >> 1) + (mem >> 2); /* 75% */
-						
+
 	if(total_mem > mem && mem) {
 		ERROR("Total memory requested is more than 75%% of physical "
 						"memory.\n");
@@ -6224,7 +6229,7 @@ static void print_options(FILE *stream, char *name, int total_mem)
 	fprintf(stream, "gid or group name\n");
 	fprintf(stream, "-pseudo-override\tmake pseudo file uids and gids ");
 	fprintf(stream, "override -all-root,\n\t\t\t-force-uid and ");
-	fprintf(stream, "-force-gid options\n"); 
+	fprintf(stream, "-force-gid options\n");
 	fprintf(stream, "-no-exports\t\tdo not make filesystem exportable via NFS (-tar default)\n");
 	fprintf(stream, "-exports\t\tmake filesystem exportable via NFS (default)\n");
 	fprintf(stream, "-no-sparse\t\tdo not detect sparse files\n");
@@ -7699,7 +7704,7 @@ int main(int argc, char *argv[])
 	 */
 	for(; i < argc; i++) {
 		struct compressor *prev_comp = comp;
-		
+
 		if(strcmp(argv[i], "-comp") == 0) {
 			if(++i == argc) {
 				ERROR("%s: -comp missing compression type\n",
@@ -8403,7 +8408,7 @@ print_compressor_options:
 				ERROR("%s: -root-becomes: missing name\n",
 					argv[0]);
 				exit(1);
-			}	
+			}
 			root_name = argv[i];
 		} else if(strcmp(argv[i], "-percentage") == 0) {
 			progressbar_percentage();
@@ -8468,7 +8473,7 @@ print_compressor_options:
 	 */
 	if(!silent)
 		progress = force_progress;
-		
+
 	/*
 	 * Sort all the xattr-add options now they're all processed
 	 */
@@ -8679,7 +8684,7 @@ print_compressor_options:
 		 */
 		if(comp_data) {
 			unsigned short c_byte = size | SQUASHFS_COMPRESSED_BIT;
-	
+
 			SQUASHFS_INSWAP_SHORTS(&c_byte, 1);
 			write_destination(fd, sizeof(struct squashfs_super_block),
 				sizeof(c_byte), &c_byte);
@@ -8688,7 +8693,7 @@ print_compressor_options:
 			bytes = sizeof(struct squashfs_super_block) + sizeof(c_byte)
 				+ size;
 			comp_opts = TRUE;
-		} else			
+		} else
 			bytes = sizeof(struct squashfs_super_block);
 	} else {
 		unsigned int last_directory_block, inode_dir_file_size,
@@ -8721,7 +8726,7 @@ print_compressor_options:
 		if((fragments = sBlk.fragments)) {
 			fragment_table = realloc((char *) fragment_table,
 				((fragments + FRAG_SIZE - 1) & ~(FRAG_SIZE - 1))
-				 * sizeof(struct squashfs_fragment_entry)); 
+				 * sizeof(struct squashfs_fragment_entry));
 			if(fragment_table == NULL)
 				BAD_ERROR("Out of memory in save filesystem state\n");
 		}
@@ -8742,7 +8747,7 @@ print_compressor_options:
 			inode_dir_file_size) & ~(SQUASHFS_METADATA_SIZE - 1);
 		uncompressed_data = ((long long) inode_dir_offset +
 			inode_dir_file_size) & (SQUASHFS_METADATA_SIZE - 1);
-		
+
 		/* save original filesystem state for restoring ... */
 		sfragments = fragments;
 		sbytes = bytes;
@@ -8810,7 +8815,7 @@ print_compressor_options:
 					"state\n");
 			memcpy(sdirectory_compressed, directory_table +
 				inode_dir_start_block,
-				sdirectory_compressed_bytes); 
+				sdirectory_compressed_bytes);
 			sdirectory_bytes = inode_dir_start_block;
 			root_inode_number = inode_dir_inode_number;
 			inode_no = sBlk.inodes + 1;
@@ -8826,7 +8831,7 @@ print_compressor_options:
 	if(path)
 		paths = add_subdir(paths, path);
 
-	dump_actions(); 
+	dump_actions();
 	dump_pseudos();
 
 	set_progressbar_state(progress);
diff --git a/squashfs-tools/unsquashfs.c b/squashfs-tools/unsquashfs.c
index f004bb7..9805241 100644
--- a/squashfs-tools/unsquashfs.c
+++ b/squashfs-tools/unsquashfs.c
@@ -188,7 +188,7 @@ int shift_overflow(int a, int shift)
 	return (INT_MAX >> shift) < a;
 }
 
- 
+
 int multiply_overflow(int a, int multiplier)
 {
 	return (INT_MAX / multiplier) < a;
@@ -256,7 +256,7 @@ void dump_queue(struct queue *queue)
 {
 	pthread_mutex_lock(&queue->mutex);
 
-	printf("Max size %d, size %d%s\n", queue->size - 1,  
+	printf("Max size %d, size %d%s\n", queue->size - 1,
 		queue->readp <= queue->writep ? queue->writep - queue->readp :
 			queue->size - queue->readp + queue->writep,
 		queue->readp == queue->writep ? " (EMPTY)" :
@@ -441,13 +441,13 @@ struct cache_entry *cache_get(struct cache *cache, long long block, int size)
 	return entry;
 }
 
-	
+
 void cache_block_ready(struct cache_entry *entry, int error)
 {
 	/*
 	 * mark cache entry as being complete, reading and (if necessary)
  	 * decompression has taken place, and the buffer is valid for use.
- 	 * If an error occurs reading or decompressing, the buffer also 
+ 	 * If an error occurs reading or decompressing, the buffer also
  	 * becomes ready but with an error...
  	 */
 	pthread_mutex_lock(&entry->cache->mutex);
@@ -569,7 +569,7 @@ void print_filename(char *pathname, struct inode *inode)
 			userstr = dummy;
 	} else
 		userstr = user->pw_name;
-		 
+
 	group = numeric ? NULL : getgrgid(inode->gid);
 	if(group == NULL) {
 		int res = snprintf(dummy2, 12, "%u", inode->gid);
@@ -601,7 +601,7 @@ void print_filename(char *pathname, struct inode *inode)
 		case S_IFCHR:
 		case S_IFBLK:
 			padchars = TOTALCHARS - strlen(userstr) -
-				strlen(groupstr) - 7; 
+				strlen(groupstr) - 7;
 
 			printf("%*s%3d,%3d ", padchars > 0 ? padchars : 0, " ",
 				(int) inode->data >> 8, (int) inode->data &
@@ -693,7 +693,7 @@ int read_block(int fd, long long start, long long *next, int expected,
 		if(read_fs_bytes(fd, start, 2, &c_byte) == FALSE)
 			goto failed;
 		c_byte = (c_byte >> 8) | ((c_byte & 0xff) << 8);
-	} else 
+	} else
 		if(read_fs_bytes(fd, start, 2, &c_byte) == FALSE)
 			goto failed;
 
@@ -1232,7 +1232,7 @@ int create_inode(char *pathname, struct inode *i)
 			break;
 		case SQUASHFS_SYMLINK_TYPE:
 		case SQUASHFS_LSYMLINK_TYPE: {
-			struct timespec times[2] = {
+			struct timeval times[2] = {
 				{ i->time, 0 },
 				{ i->time, 0 }
 			};
@@ -1251,8 +1251,7 @@ int create_inode(char *pathname, struct inode *i)
 				goto failed;
 			}
 
-			res = utimensat(AT_FDCWD, pathname, times,
-					AT_SYMLINK_NOFOLLOW);
+			res = lutimes(pathname, times);
 			if(res == -1) {
 				EXIT_UNSQUASH_STRICT("create_inode: failed to"
 					" set time on %s, because %s\n",
@@ -2172,7 +2171,7 @@ int dir_scan(char *parent_name, unsigned int start_block, unsigned int offset,
 					parent_name, strerror(errno));
 				squashfs_closedir(dir);
 				return FALSE;
-			} 
+			}
 
 			/*
 			 * Try to change permissions of existing directory so
@@ -2681,7 +2680,7 @@ void *inflator(void *arg)
 		 * block has been either successfully decompressed, or an error
  		 * occurred, clear pending flag, set error appropriately and
  		 * wake up any threads waiting on this block
- 		 */ 
+ 		 */
 		cache_block_ready(entry, res == -1);
 	}
 }
@@ -2741,6 +2740,7 @@ void initialise_threads(int fragment_buffer_size, int data_buffer_size, int cat_
 		sigemptyset(&sigmask);
 		sigaddset(&sigmask, SIGQUIT);
 		sigaddset(&sigmask, SIGHUP);
+		sigaddset(&sigmask, SIGALRM);
 		if(pthread_sigmask(SIG_BLOCK, &sigmask, NULL) != 0)
 			EXIT_UNSQUASH("Failed to set signal mask in initialise_threads\n");
 
@@ -4035,7 +4035,7 @@ static void print_options(FILE *stream, char *name)
 	fprintf(stream, "\tUnsquashfs did not continue and aborted.\n");
 	fprintf(stream, "  2\tNon-fatal errors occurred, e.g. no support for ");
 	fprintf(stream, "XATTRs, Symbolic links\n\tin output filesystem or ");
-	fprintf(stream, "couldn't write permissions to output filesystem.\n"); 
+	fprintf(stream, "couldn't write permissions to output filesystem.\n");
 	fprintf(stream, "\tUnsquashfs continued and did not abort.\n");
 	fprintf(stream, "\nSee -ignore-errors, -strict-errors and ");
 	fprintf(stream, "-no-exit-code options for how they affect\nthe exit ");
@@ -4308,7 +4308,7 @@ int parse_options(int argc, char *argv[])
 			dest = argv[i];
 		} else if(strcmp(argv[i], "-processors") == 0 ||
 				strcmp(argv[i], "-p") == 0) {
-			if((++i == argc) || 
+			if((++i == argc) ||
 					!parse_number(argv[i],
 						&processors)) {
 				ERROR("%s: -processors missing or invalid "
diff --git a/squashfs-tools/unsquashfs.h b/squashfs-tools/unsquashfs.h
index 8871d6f..f49234b 100644
--- a/squashfs-tools/unsquashfs.h
+++ b/squashfs-tools/unsquashfs.h
@@ -46,6 +46,10 @@
 #include <sys/ioctl.h>
 #include <sys/time.h>
 
+#ifndef FNM_EXTMATCH /* glibc extension */
+        #define FNM_EXTMATCH 0
+#endif
+
 #include "endian_compat.h"
 #include "squashfs_fs.h"
 #include "unsquashfs_error.h"
diff --git a/squashfs-tools/unsquashfs_info.c b/squashfs-tools/unsquashfs_info.c
index 2be9f66..f53f055 100644
--- a/squashfs-tools/unsquashfs_info.c
+++ b/squashfs-tools/unsquashfs_info.c
@@ -97,11 +97,12 @@ void dump_state()
 void *info_thrd(void *arg)
 {
 	sigset_t sigmask;
-	int sig, waiting = 0;
+	int sig, err, waiting = 0;
 
 	sigemptyset(&sigmask);
 	sigaddset(&sigmask, SIGQUIT);
 	sigaddset(&sigmask, SIGHUP);
+	sigaddset(&sigmask, SIGALRM);
 
 	while(1) {
 		sig = wait_for_signal(&sigmask, &waiting);
@@ -113,8 +114,12 @@ void *info_thrd(void *arg)
 			/* set one second interval period, if ^\ received
 			   within then, dump queue and cache status */
 			waiting = 1;
-		} else
-			dump_state();
+			alarm(1);
+		} else if (sig == SIGQUIT) {
+ 			dump_state();
+		} else if (sig == SIGALRM) {
+			waiting = 0;
+		}
 	}
 }
 
diff --git a/squashfs-tools/unsquashfs_xattr.c b/squashfs-tools/unsquashfs_xattr.c
index fdc1abd..47e5624 100644
--- a/squashfs-tools/unsquashfs_xattr.c
+++ b/squashfs-tools/unsquashfs_xattr.c
@@ -27,6 +27,11 @@
 
 #include <sys/xattr.h>
 
+#ifdef XATTR_NOFOLLOW /* Apple's xattrs */
+	#define lsetxattr(path_, name_, val_, sz_, flags_) \
+		setxattr(path_, name_, val_, sz_, 0, flags_ | XATTR_NOFOLLOW)
+#endif
+
 #define NOSPACE_MAX 10
 
 extern int root_process;
@@ -79,7 +84,7 @@ static void print_xattr_name_value(struct xattr_list *xattr, int writer_fd)
 		value = new;
 	} else
 		count = xattr->vsize;
-	
+
 	res = dprintf(writer_fd, "%s=", xattr->full_name);
 	if(res == -1)
 		EXIT_UNSQUASH("Failed to write to pseudo output file\n");
@@ -204,7 +209,7 @@ int write_xattr(char *pathname, unsigned int xattr)
 					 * is rather annoying
 					 */
 					ERROR("write_xattr: failed to write "
-						"xattr %s for file %s because " 
+						"xattr %s for file %s because "
 						"extended attributes are not "
 						"supported by the destination "
 						"filesystem\n",
@@ -228,7 +233,7 @@ int write_xattr(char *pathname, unsigned int xattr)
 					 * then suppress the error messsage
 					 */
 					EXIT_UNSQUASH_IGNORE("write_xattr: failed to write "
-						"xattr %s for file %s because " 
+						"xattr %s for file %s because "
 						"no extended attribute space "
 						"remaining (per file or "
 						"filesystem limit)\n",
diff --git a/squashfs-tools/xattr.c b/squashfs-tools/xattr.c
index 32343f5..f69ca84 100644
--- a/squashfs-tools/xattr.c
+++ b/squashfs-tools/xattr.c
@@ -22,6 +22,8 @@
  * xattr.c
  */
 
+#include "endian_compat.h"
+
 #define TRUE 1
 #define FALSE 0
 
@@ -48,6 +50,13 @@
 #include "action.h"
 #include "merge_sort.h"
 
+#ifdef XATTR_NOFOLLOW /* Apple's xattrs */
+	#define llistxattr(path_, buf_, sz_) \
+		listxattr(path_, buf_, sz_, XATTR_NOFOLLOW)
+	#define lgetxattr(path_, name_, val_, sz_) \
+		getxattr(path_, name_, val_, sz_, 0, XATTR_NOFOLLOW)
+#endif
+
 /* compressed xattr table */
 static char *xattr_table = NULL;
 static unsigned int xattr_size = 0;
@@ -133,7 +142,7 @@ int xattr_get_prefix(struct xattr_list *xattr, char *name)
 	return type;
 }
 
-	
+
 static int read_xattrs_from_system(struct dir_ent *dir_ent, char *filename,
 						struct xattr_list **xattrs)
 {
@@ -260,7 +269,7 @@ static int read_xattrs_from_system(struct dir_ent *dir_ent, char *filename,
 					goto failed;
 				}
 			}
-			
+
 			break;
 		}
 
@@ -387,7 +396,7 @@ static struct dupl_id *check_id_dupl(struct xattr_list *xattr_list, int xattrs)
 			if(memcmp(xattr->value, dup_xattr->value, xattr->vsize))
 				break;
 		}
-		
+
 		if(i == xattrs)
 			break;
 	}
@@ -403,7 +412,7 @@ static struct dupl_id *check_id_dupl(struct xattr_list *xattr_list, int xattrs)
 		entry->next = dupl_id[checksum];
 		dupl_id[checksum] = entry;
 	}
-		
+
 	return entry;
 }
 
@@ -420,7 +429,7 @@ static void check_value_dupl(struct xattr_list *xattr)
 	for(entry = dupl_value[xattr->vchecksum]; entry; entry = entry->vnext) {
 		if(entry->vsize != xattr->vsize)
 			continue;
-		
+
 		if(memcmp(entry->value, xattr->value, xattr->vsize) == 0)
 			break;
 	}
@@ -480,7 +489,7 @@ static int get_xattr_id(int xattrs, struct xattr_list *xattr_list,
 	xattr_dupl->xattr_id = xattr_ids ++;
 	return xattr_dupl->xattr_id;
 }
-	
+
 
 long long write_xattrs()
 {
@@ -568,7 +577,7 @@ int generate_xattrs(int xattrs, struct xattr_list *xattr_list)
 		free_xattr_list(xattrs, xattr_list);
 		return xattr_dupl->xattr_id;
 	}
-	 
+
 	/*
 	 * Scan the xattr_list deciding which type to assign to each
 	 * xattr.  The choice is fairly straightforward, and depends on the
@@ -1070,7 +1079,7 @@ char *hex_decode(char *source, int size, int *bytes)
 		if(size % 2 == 0)
 			first = digit;
 		else
-			*dest_ptr ++ = (first << 4) | digit; 
+			*dest_ptr ++ = (first << 4) | digit;
 	}
 
 	*bytes = dest_ptr - (unsigned char *) dest;
