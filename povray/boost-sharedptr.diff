diff --git a/libraries/boost/boost/archive/binary_iarchive.hpp b/libraries/boost/boost/archive/binary_iarchive.hpp
index 638d996..79e5f88 100644
--- a/libraries/boost/boost/archive/binary_iarchive.hpp
+++ b/libraries/boost/boost/archive/binary_iarchive.hpp
@@ -32,7 +32,7 @@ namespace archive {
 // via inhertance, derived from text_iarchive_impl instead.  This will
 // preserve correct static polymorphism.
 
-// same as binary_iarchive below - without the shared_ptr_helper
+// same as binary_iarchive below - without the boost::shared_ptr_helper
 class naked_binary_iarchive : 
     public binary_iarchive_impl<
         boost::archive::naked_binary_iarchive, 
@@ -56,9 +56,9 @@ public:
 } // namespace archive
 } // namespace boost
 
-// note special treatment of shared_ptr. This type needs a special
+// note special treatment of boost::shared_ptr. This type needs a special
 // structure associated with every archive.  We created a "mix-in"
-// class to provide this functionality.  Since shared_ptr holds a
+// class to provide this functionality.  Since boost::shared_ptr holds a
 // special esteem in the boost library - we included it here by default.
 #include <boost/archive/shared_ptr_helper.hpp>
 
diff --git a/libraries/boost/boost/archive/binary_wiarchive.hpp b/libraries/boost/boost/archive/binary_wiarchive.hpp
index b5f6a71..893ce38 100644
--- a/libraries/boost/boost/archive/binary_wiarchive.hpp
+++ b/libraries/boost/boost/archive/binary_wiarchive.hpp
@@ -28,7 +28,7 @@
 namespace boost { 
 namespace archive {
 
-// same as binary_wiarchive below - without the shared_ptr_helper
+// same as binary_wiarchive below - without the boost::shared_ptr_helper
 class naked_binary_wiarchive : 
     public binary_iarchive_impl<
         boost::archive::naked_binary_wiarchive, 
@@ -56,9 +56,9 @@ public:
 } // namespace archive
 } // namespace boost
 
-// note special treatment of shared_ptr. This type needs a special
+// note special treatment of boost::shared_ptr. This type needs a special
 // structure associated with every archive.  We created a "mix-in"
-// class to provide this functionality.  Since shared_ptr holds a
+// class to provide this functionality.  Since boost::shared_ptr holds a
 // special esteem in the boost library - we included it here by default.
 #include <boost/archive/shared_ptr_helper.hpp>
 
diff --git a/libraries/boost/boost/archive/polymorphic_iarchive.hpp b/libraries/boost/boost/archive/polymorphic_iarchive.hpp
index 2f76cf2..f417677 100644
--- a/libraries/boost/boost/archive/polymorphic_iarchive.hpp
+++ b/libraries/boost/boost/archive/polymorphic_iarchive.hpp
@@ -40,7 +40,7 @@ namespace std{
 
 namespace boost {
 template<class T>
-class shared_ptr;
+class boost::shared_ptr;
 namespace serialization {
     class extended_type_info;
 } // namespace serialization
@@ -155,9 +155,9 @@ public:
 
 #include <boost/archive/detail/abi_suffix.hpp> // pops abi_suffix.hpp pragmas
 
-// note special treatment of shared_ptr. This type needs a special
+// note special treatment of boost::shared_ptr. This type needs a special
 // structure associated with every archive.  We created a "mix-in"
-// class to provide this functionality.  Since shared_ptr holds a
+// class to provide this functionality.  Since boost::shared_ptr holds a
 // special esteem in the boost library - we included it here by default.
 #include <boost/archive/shared_ptr_helper.hpp>
 
diff --git a/libraries/boost/boost/archive/polymorphic_oarchive.hpp b/libraries/boost/boost/archive/polymorphic_oarchive.hpp
index 420029b..f7d02c4 100644
--- a/libraries/boost/boost/archive/polymorphic_oarchive.hpp
+++ b/libraries/boost/boost/archive/polymorphic_oarchive.hpp
@@ -39,7 +39,7 @@ namespace std{
 
 namespace boost {
 template<class T>
-class shared_ptr;
+class boost::shared_ptr;
 namespace serialization {
     class extended_type_info;
 } // namespace serialization
diff --git a/libraries/boost/boost/archive/shared_ptr_helper.hpp b/libraries/boost/boost/archive/shared_ptr_helper.hpp
index 0e5f4f2..519258d 100644
--- a/libraries/boost/boost/archive/shared_ptr_helper.hpp
+++ b/libraries/boost/boost/archive/shared_ptr_helper.hpp
@@ -7,7 +7,7 @@
 #endif
 
 /////////1/////////2/////////3/////////4/////////5/////////6/////////7/////////8
-// shared_ptr_helper.hpp: serialization for boost shared pointern
+// boost::shared_ptr_helper.hpp: serialization for boost shared pointern
 
 // (C) Copyright 2004-2009 Robert Ramey, Martin Ecker and Takatoshi Kondo
 // Use, modification and distribution is subject to the Boost Software
@@ -35,10 +35,10 @@
 #include <boost/archive/detail/abi_prefix.hpp> // must be the last headern
 
 namespace boost_132 {
-    template<class T> class shared_ptr;
+    template<class T> class boost::shared_ptr;
 }
 namespace boost {
-    template<class T> class shared_ptr;
+    template<class T> class boost::shared_ptr;
     namespace serialization {
         class extended_type_info;
         template<class Archive, class T>
@@ -54,11 +54,11 @@ namespace detail {
 /////////1/////////2/////////3/////////4/////////5/////////6/////////7/////////8
 // a common class for holding various types of shared pointers
 
-class shared_ptr_helper {
+class boost::shared_ptr_helper {
     struct collection_type_compare {
         bool operator()(
-            const shared_ptr<const void> &lhs,
-            const shared_ptr<const void> &rhs
+            const boost::shared_ptr<const void> &lhs,
+            const boost::shared_ptr<const void> &rhs
         )const{
             return lhs.get() < rhs.get();
         }
@@ -72,7 +72,7 @@ class shared_ptr_helper {
     // is used to "match up" shared pointers loaded at different
     // points in the archive. Note, we delay construction until
     // it is actually used since this is by default included as
-    // a "mix-in" even if shared_ptr isn't used.
+    // a "mix-in" even if boost::shared_ptr isn't used.
     collection_type * m_pointers;
 
     struct null_deleter {
@@ -114,7 +114,7 @@ public:
 
     // returns pointer to object and an indicator whether this is a
     // new entry (true) or a previous one (false)
-    BOOST_ARCHIVE_DECL(shared_ptr<void>) 
+    BOOST_ARCHIVE_DECL(boost::shared_ptr<void>) 
     get_od(
         const void * od,
         const boost::serialization::extended_type_info * true_type, 
@@ -146,7 +146,7 @@ public:
     };
 public:
     template<class T>
-    void reset(shared_ptr< T > & s, T * t){
+    void reset(boost::shared_ptr< T > & s, T * t){
         if(NULL == t){
             s.reset();
             return;
@@ -175,7 +175,7 @@ public:
                     this_type->get_debug_info()
                 )
             );
-        shared_ptr<void> r =
+        boost::shared_ptr<void> r =
             get_od(
                 static_cast<const void *>(t), 
                 true_type,
@@ -188,11 +188,11 @@ public:
                 *this_type,
                 static_cast<const void *>(t)
             );
-            shared_ptr<const void> sp(s, od);
+            boost::shared_ptr<const void> sp(s, od);
             append(sp);
         }
         else{
-            s = shared_ptr< T >(
+            s = boost::shared_ptr< T >(
                 r,
                 static_cast<T *>(r.get())
             );
@@ -205,7 +205,7 @@ public:
 //  #endif
 public:
     BOOST_ARCHIVE_DECL(BOOST_PP_EMPTY())
-    shared_ptr_helper();
+    boost::shared_ptr_helper();
     BOOST_ARCHIVE_DECL(BOOST_PP_EMPTY())
     ~shared_ptr_helper();
 };
diff --git a/libraries/boost/boost/archive/text_iarchive.hpp b/libraries/boost/boost/archive/text_iarchive.hpp
index 6e60105..5f3b5a7 100644
--- a/libraries/boost/boost/archive/text_iarchive.hpp
+++ b/libraries/boost/boost/archive/text_iarchive.hpp
@@ -95,7 +95,7 @@ protected:
 // via inhertance, derived from text_iarchive_impl instead.  This will
 // preserve correct static polymorphism.
 
-// same as text_iarchive below - without the shared_ptr_helper
+// same as text_iarchive below - without the boost::shared_ptr_helper
 class naked_text_iarchive : 
     public text_iarchive_impl<naked_text_iarchive>
 {
@@ -116,9 +116,9 @@ public:
 
 #include <boost/archive/detail/abi_suffix.hpp> // pops abi_suffix.hpp pragmas
 
-// note special treatment of shared_ptr. This type needs a special
+// note special treatment of boost::shared_ptr. This type needs a special
 // structure associated with every archive.  We created a "mix-in"
-// class to provide this functionality.  Since shared_ptr holds a
+// class to provide this functionality.  Since boost::shared_ptr holds a
 // special esteem in the boost library - we included it here by default.
 #include <boost/archive/shared_ptr_helper.hpp>
 
diff --git a/libraries/boost/boost/archive/text_wiarchive.hpp b/libraries/boost/boost/archive/text_wiarchive.hpp
index 7451f3a..d7f9a58 100644
--- a/libraries/boost/boost/archive/text_wiarchive.hpp
+++ b/libraries/boost/boost/archive/text_wiarchive.hpp
@@ -93,7 +93,7 @@ protected:
 // via inhertance, derived from text_iarchive_impl instead.  This will
 // preserve correct static polymorphism.
 
-// same as text_wiarchive below - without the shared_ptr_helper
+// same as text_wiarchive below - without the boost::shared_ptr_helper
 class naked_text_wiarchive : 
     public text_wiarchive_impl<naked_text_wiarchive>
 {
@@ -113,9 +113,9 @@ public:
 
 #include <boost/archive/detail/abi_suffix.hpp> // pops abi_suffix.hpp pragmas
 
-// note special treatment of shared_ptr. This type needs a special
+// note special treatment of boost::shared_ptr. This type needs a special
 // structure associated with every archive.  We created a "mix-in"
-// class to provide this functionality.  Since shared_ptr holds a
+// class to provide this functionality.  Since boost::shared_ptr holds a
 // special esteem in the boost library - we included it here by default.
 #include <boost/archive/shared_ptr_helper.hpp>
 
diff --git a/libraries/boost/boost/archive/xml_iarchive.hpp b/libraries/boost/boost/archive/xml_iarchive.hpp
index be6cfe4..ffc3757 100644
--- a/libraries/boost/boost/archive/xml_iarchive.hpp
+++ b/libraries/boost/boost/archive/xml_iarchive.hpp
@@ -106,7 +106,7 @@ protected:
 // via inhertance, derived from text_iarchive_impl instead.  This will
 // preserve correct static polymorphism.
 
-// same as xml_iarchive below - without the shared_ptr_helper
+// same as xml_iarchive below - without the boost::shared_ptr_helper
 class naked_xml_iarchive : 
     public xml_iarchive_impl<naked_xml_iarchive>
 {
@@ -126,9 +126,9 @@ public:
 
 #include <boost/archive/detail/abi_suffix.hpp> // pops abi_suffix.hpp pragmas
 
-// note special treatment of shared_ptr. This type needs a special
+// note special treatment of boost::shared_ptr. This type needs a special
 // structure associated with every archive.  We created a "mix-in"
-// class to provide this functionality.  Since shared_ptr holds a
+// class to provide this functionality.  Since boost::shared_ptr holds a
 // special esteem in the boost library - we included it here by default.
 #include <boost/archive/shared_ptr_helper.hpp>
 
diff --git a/libraries/boost/boost/archive/xml_wiarchive.hpp b/libraries/boost/boost/archive/xml_wiarchive.hpp
index 09552ce..127fd1c 100644
--- a/libraries/boost/boost/archive/xml_wiarchive.hpp
+++ b/libraries/boost/boost/archive/xml_wiarchive.hpp
@@ -111,7 +111,7 @@ protected:
 // via inhertance, derived from xml_wiarchive_impl instead.  This will
 // preserve correct static polymorphism.
 
-// same as xml_wiarchive below - without the shared_ptr_helper
+// same as xml_wiarchive below - without the boost::shared_ptr_helper
 class naked_xml_wiarchive : 
     public xml_wiarchive_impl<naked_xml_wiarchive>
 {
@@ -132,9 +132,9 @@ public:
 
 #include <boost/archive/detail/abi_suffix.hpp> // pops abi_suffix.hpp pragmas
 
-// note special treatment of shared_ptr. This type needs a special
+// note special treatment of boost::shared_ptr. This type needs a special
 // structure associated with every archive.  We created a "mix-in"
-// class to provide this functionality.  Since shared_ptr holds a
+// class to provide this functionality.  Since boost::shared_ptr holds a
 // special esteem in the boost library - we included it here by default.
 #include <boost/archive/shared_ptr_helper.hpp>
 
diff --git a/libraries/boost/boost/config/compiler/gcc.hpp b/libraries/boost/boost/config/compiler/gcc.hpp
index eeaf998..ddca9f0 100644
--- a/libraries/boost/boost/config/compiler/gcc.hpp
+++ b/libraries/boost/boost/config/compiler/gcc.hpp
@@ -15,7 +15,7 @@
 
 #if __GNUC__ < 3
 #   if __GNUC_MINOR__ == 91
-       // egcs 1.1 won't parse shared_ptr.hpp without this:
+       // egcs 1.1 won't parse boost::shared_ptr.hpp without this:
 #      define BOOST_NO_AUTO_PTR
 #   endif
 #   if __GNUC_MINOR__ < 95
diff --git a/libraries/boost/boost/config/platform/win32.hpp b/libraries/boost/boost/config/platform/win32.hpp
index f59c4ea..38b13dc 100644
--- a/libraries/boost/boost/config/platform/win32.hpp
+++ b/libraries/boost/boost/config/platform/win32.hpp
@@ -46,7 +46,7 @@
 // defined but no longer - this should allow some
 // files to be compiled in strict mode - while maintaining
 // a consistent setting of BOOST_HAS_THREADS across
-// all translation units (needed for shared_ptr etc).
+// all translation units (needed for boost::shared_ptr etc).
 //
 
 #ifdef _WIN32_WCE
diff --git a/libraries/boost/boost/date_time/local_time/local_date_time.hpp b/libraries/boost/boost/date_time/local_time/local_date_time.hpp
index 9c9f623..2f95b1e 100644
--- a/libraries/boost/boost/date_time/local_time/local_date_time.hpp
+++ b/libraries/boost/boost/date_time/local_time/local_date_time.hpp
@@ -384,7 +384,7 @@ namespace local_time {
     //! returns a posix_time_zone string for the associated time_zone. If no time_zone, "UTC+00" is returned.
     std::string zone_as_posix_string() const
     {
-      if(zone_ == shared_ptr<tz_type>()) {
+      if(zone_ == boost::shared_ptr<tz_type>()) {
         return std::string("UTC+00");
       }
       return zone_->to_posix_string();
diff --git a/libraries/boost/boost/date_time/local_time/posix_time_zone.hpp b/libraries/boost/boost/date_time/local_time/posix_time_zone.hpp
index 2a0199f..4a067ff 100644
--- a/libraries/boost/boost/date_time/local_time/posix_time_zone.hpp
+++ b/libraries/boost/boost/date_time/local_time/posix_time_zone.hpp
@@ -399,7 +399,7 @@ namespace local_time{
       ew = lexical_cast<unsigned short>(*it++);
       ed = lexical_cast<unsigned short>(*it);
 
-      dst_calc_rules_ = shared_ptr<dst_calc_rule>(
+      dst_calc_rules_ = boost::shared_ptr<dst_calc_rule>(
         new nth_kday_dst_rule(
           nth_last_dst_rule::start_rule(
             static_cast<nkday::week_num>(sw),sd,sm),
@@ -427,7 +427,7 @@ namespace local_time{
         ed -= calendar::end_of_month_day(year,em++);
       }
 
-      dst_calc_rules_ = shared_ptr<dst_calc_rule>(
+      dst_calc_rules_ = boost::shared_ptr<dst_calc_rule>(
         new partial_date_dst_rule(
           partial_date_dst_rule::start_rule(
             sd, static_cast<date_time::months_of_year>(sm)),
@@ -443,7 +443,7 @@ namespace local_time{
       int sd=0, ed=0;
       sd = lexical_cast<int>(s);
       ed = lexical_cast<int>(e);
-      dst_calc_rules_ = shared_ptr<dst_calc_rule>(
+      dst_calc_rules_ = boost::shared_ptr<dst_calc_rule>(
         new partial_date_dst_rule(
           partial_date_dst_rule::start_rule(++sd),// args are 0-365
           partial_date_dst_rule::end_rule(++ed) // pd expects 1-366
diff --git a/libraries/boost/boost/date_time/microsec_time_clock.hpp b/libraries/boost/boost/date_time/microsec_time_clock.hpp
index 9396579..9a56352 100644
--- a/libraries/boost/boost/date_time/microsec_time_clock.hpp
+++ b/libraries/boost/boost/date_time/microsec_time_clock.hpp
@@ -50,7 +50,7 @@ namespace date_time {
     //! return a local time object for the given zone, based on computer clock
     //JKG -- looks like we could rewrite this against universal_time
     template<class time_zone_type>
-    static time_type local_time(shared_ptr<time_zone_type> tz_ptr)
+    static time_type local_time(boost::shared_ptr<time_zone_type> tz_ptr)
     {
       typedef typename time_type::utc_time_type utc_time_type;
       typedef second_clock<utc_time_type> second_clock;
diff --git a/libraries/boost/boost/exception/detail/exception_ptr.hpp b/libraries/boost/boost/exception/detail/exception_ptr.hpp
index 0510fe2..6d63756 100644
--- a/libraries/boost/boost/exception/detail/exception_ptr.hpp
+++ b/libraries/boost/boost/exception/detail/exception_ptr.hpp
@@ -28,7 +28,7 @@
 namespace
 boost
     {
-    typedef shared_ptr<exception_detail::clone_base const> exception_ptr;
+    typedef boost::shared_ptr<exception_detail::clone_base const> exception_ptr;
 
     exception_ptr current_exception();
 
diff --git a/libraries/boost/boost/exception/errinfo_nested_exception.hpp b/libraries/boost/boost/exception/errinfo_nested_exception.hpp
index e4e75d9..0599341 100644
--- a/libraries/boost/boost/exception/errinfo_nested_exception.hpp
+++ b/libraries/boost/boost/exception/errinfo_nested_exception.hpp
@@ -11,8 +11,8 @@ boost
     {
     namespace exception_detail { class clone_base; };
     template <class Tag,class T> class error_info;
-    template <class T> class shared_ptr;
-    typedef shared_ptr<exception_detail::clone_base const> exception_ptr;
+    template <class T> class boost::shared_ptr;
+    typedef boost::shared_ptr<exception_detail::clone_base const> exception_ptr;
     typedef error_info<struct errinfo_nested_exception_,exception_ptr> errinfo_nested_exception;
     }
 
diff --git a/libraries/boost/boost/exception/exception.hpp b/libraries/boost/boost/exception/exception.hpp
index adaac68..3fb3803 100644
--- a/libraries/boost/boost/exception/exception.hpp
+++ b/libraries/boost/boost/exception/exception.hpp
@@ -135,7 +135,7 @@ boost
     class exception;
 
     template <class T>
-    class shared_ptr;
+    class boost::shared_ptr;
 
     namespace
     exception_detail
@@ -147,8 +147,8 @@ boost
         error_info_container
             {
             virtual char const * diagnostic_information( char const * ) const = 0;
-            virtual shared_ptr<error_info_base> get( type_info_ const & ) const = 0;
-            virtual void set( shared_ptr<error_info_base> const &, type_info_ const & ) = 0;
+            virtual boost::shared_ptr<error_info_base> get( type_info_ const & ) const = 0;
+            virtual void set( boost::shared_ptr<error_info_base> const &, type_info_ const & ) = 0;
             virtual void add_ref() const = 0;
             virtual bool release() const = 0;
             virtual refcount_ptr<exception_detail::error_info_container> clone() const = 0;
diff --git a/libraries/boost/boost/exception/get_error_info.hpp b/libraries/boost/boost/exception/get_error_info.hpp
index 046f05a..66e2e0e 100644
--- a/libraries/boost/boost/exception/get_error_info.hpp
+++ b/libraries/boost/boost/exception/get_error_info.hpp
@@ -32,7 +32,7 @@ boost
             get( exception const & x )
                 {
                 if( exception_detail::error_info_container * c=x.data_.get() )
-                    if( shared_ptr<exception_detail::error_info_base> eib = c->get(BOOST_EXCEPTION_STATIC_TYPEID(ErrorInfo)) )
+                    if( boost::shared_ptr<exception_detail::error_info_base> eib = c->get(BOOST_EXCEPTION_STATIC_TYPEID(ErrorInfo)) )
                         {
 #ifndef BOOST_NO_RTTI
                         BOOST_ASSERT( 0!=dynamic_cast<ErrorInfo *>(eib.get()) );
diff --git a/libraries/boost/boost/exception/info.hpp b/libraries/boost/boost/exception/info.hpp
index c918dbd..429e711 100644
--- a/libraries/boost/boost/exception/info.hpp
+++ b/libraries/boost/boost/exception/info.hpp
@@ -82,26 +82,26 @@ boost
                 }
 
             void
-            set( shared_ptr<error_info_base> const & x, type_info_ const & typeid_ )
+            set( boost::shared_ptr<error_info_base> const & x, type_info_ const & typeid_ )
                 {
                 BOOST_ASSERT(x);
                 info_[typeid_] = x;
                 diagnostic_info_str_.clear();
                 }
 
-            shared_ptr<error_info_base>
+            boost::shared_ptr<error_info_base>
             get( type_info_ const & ti ) const
                 {
                 error_info_map::const_iterator i=info_.find(ti);
                 if( info_.end()!=i )
                     {
-                    shared_ptr<error_info_base> const & p = i->second;
+                    boost::shared_ptr<error_info_base> const & p = i->second;
 #ifndef BOOST_NO_RTTI
                     BOOST_ASSERT( BOOST_EXCEPTION_DYNAMIC_TYPEID(*p).type_==ti.type_ );
 #endif
                     return p;
                     }
-                return shared_ptr<error_info_base>();
+                return boost::shared_ptr<error_info_base>();
                 }
 
             char const *
@@ -126,7 +126,7 @@ boost
 
             friend class boost::exception;
 
-            typedef std::map< type_info_, shared_ptr<error_info_base> > error_info_map;
+            typedef std::map< type_info_, boost::shared_ptr<error_info_base> > error_info_map;
             error_info_map info_;
             mutable std::string diagnostic_info_str_;
             mutable int count_;
@@ -169,7 +169,7 @@ boost
         set_info( E const & x, error_info<Tag,T> const & v )
             {
             typedef error_info<Tag,T> error_info_tag_t;
-            shared_ptr<error_info_tag_t> p( new error_info_tag_t(v) );
+            boost::shared_ptr<error_info_tag_t> p( new error_info_tag_t(v) );
             exception_detail::error_info_container * c=x.data_.get();
             if( !c )
                 x.data_.adopt(c=new exception_detail::error_info_container_impl);
diff --git a/libraries/boost/boost/format/alt_sstream.hpp b/libraries/boost/boost/format/alt_sstream.hpp
index e236be3..f0c3990 100644
--- a/libraries/boost/boost/format/alt_sstream.hpp
+++ b/libraries/boost/boost/format/alt_sstream.hpp
@@ -118,7 +118,7 @@ namespace boost {
 // ---   class basic_oaltstringstream ----------------------------------------
         template <class Ch, class Tr, class Alloc>
         class basic_oaltstringstream 
-            : private base_from_member< shared_ptr< basic_altstringbuf< Ch, Tr, Alloc> > >,
+            : private base_from_member< boost::shared_ptr< basic_altstringbuf< Ch, Tr, Alloc> > >,
               public ::std::basic_ostream<Ch, Tr>
         {
             class No_Op { 
diff --git a/libraries/boost/boost/get_pointer.hpp b/libraries/boost/boost/get_pointer.hpp
index a0cd5c0..ab956f9 100644
--- a/libraries/boost/boost/get_pointer.hpp
+++ b/libraries/boost/boost/get_pointer.hpp
@@ -20,7 +20,7 @@ template<class T> T * get_pointer(T * p)
     return p;
 }
 
-// get_pointer(shared_ptr<T> const & p) has been moved to shared_ptr.hpp
+// get_pointer(boost::shared_ptr<T> const & p) has been moved to boost::shared_ptr.hpp
 
 template<class T> T * get_pointer(std::auto_ptr<T> const& p)
 {
diff --git a/libraries/boost/boost/pointee.hpp b/libraries/boost/boost/pointee.hpp
index 9794b8e..68b6e27 100644
--- a/libraries/boost/boost/pointee.hpp
+++ b/libraries/boost/boost/pointee.hpp
@@ -8,7 +8,7 @@
 //
 // typename pointee<P>::type provides the pointee type of P.
 //
-// For example, it is T for T* and X for shared_ptr<X>.
+// For example, it is T for T* and X for boost::shared_ptr<X>.
 //
 // http://www.boost.org/libs/iterator/doc/pointee.html
 //
diff --git a/libraries/boost/boost/program_options/detail/config_file.hpp b/libraries/boost/boost/program_options/detail/config_file.hpp
index 91caac7..114e39d 100644
--- a/libraries/boost/boost/program_options/detail/config_file.hpp
+++ b/libraries/boost/boost/program_options/detail/config_file.hpp
@@ -126,7 +126,7 @@ namespace boost { namespace program_options { namespace detail {
         bool getline(std::string&);
 
     private: // internal data
-        shared_ptr<std::basic_istream<charT> > is;
+        boost::shared_ptr<std::basic_istream<charT> > is;
     };
     
     typedef basic_config_file_iterator<char> config_file_iterator;
diff --git a/libraries/boost/boost/program_options/options_description.hpp b/libraries/boost/boost/program_options/options_description.hpp
index eff1f90..43ee360 100644
--- a/libraries/boost/boost/program_options/options_description.hpp
+++ b/libraries/boost/boost/program_options/options_description.hpp
@@ -108,7 +108,7 @@ namespace program_options {
         const std::string& description() const;
 
         /// Semantic of option's value
-        shared_ptr<const value_semantic> semantic() const;
+        boost::shared_ptr<const value_semantic> semantic() const;
         
         /// Returns the option name, formatted suitably for usage message. 
         std::string format_name() const;
@@ -122,9 +122,9 @@ namespace program_options {
         option_description& set_name(const char* name);
 
         std::string m_short_name, m_long_name, m_description;
-        // shared_ptr is needed to simplify memory management in
+        // boost::shared_ptr is needed to simplify memory management in
         // copy ctor and destructor.
-        shared_ptr<const value_semantic> m_value_semantic;
+        boost::shared_ptr<const value_semantic> m_value_semantic;
     };
 
     class options_description;
@@ -180,7 +180,7 @@ namespace program_options {
         /** Adds new variable description. Throws duplicate_variable_error if
             either short or long name matches that of already present one. 
         */
-        void add(shared_ptr<option_description> desc);
+        void add(boost::shared_ptr<option_description> desc);
         /** Adds a group of option description. This has the same
             effect as adding all option_descriptions in 'desc' 
             individually, except that output operator will show
@@ -209,7 +209,7 @@ namespace program_options {
                                                bool short_ignore_case = false) const;
 
 
-        const std::vector< shared_ptr<option_description> >& options() const;
+        const std::vector< boost::shared_ptr<option_description> >& options() const;
 
         /** Produces a human readable output of 'desc', listing options,
             their descriptions and allowed parameters. Other options_description
@@ -235,7 +235,7 @@ namespace program_options {
         // Data organization is chosen because:
         // - there could be two names for one option
         // - option_add_proxy needs to know the last added option
-        std::vector< shared_ptr<option_description> > m_options;
+        std::vector< boost::shared_ptr<option_description> > m_options;
 
         // Whether the option comes from one of declared groups.
 #if BOOST_WORKAROUND(BOOST_DINKUMWARE_STDLIB, BOOST_TESTED_AT(313))
@@ -246,7 +246,7 @@ namespace program_options {
         std::vector<bool> belong_to_group;
 #endif
 
-        std::vector< shared_ptr<options_description> > groups;
+        std::vector< boost::shared_ptr<options_description> > groups;
 
     };
 
diff --git a/libraries/boost/boost/program_options/variables_map.hpp b/libraries/boost/boost/program_options/variables_map.hpp
index 9621e05..d32955b 100644
--- a/libraries/boost/boost/program_options/variables_map.hpp
+++ b/libraries/boost/boost/program_options/variables_map.hpp
@@ -92,7 +92,7 @@ namespace boost { namespace program_options {
         // they are known only after all sources are stored. By that
         // time options_description for the first source might not
         // be easily accessible, so we need to store semantic here.
-        shared_ptr<const value_semantic> m_value_semantic;
+        boost::shared_ptr<const value_semantic> m_value_semantic;
 
         friend BOOST_PROGRAM_OPTIONS_DECL
         void store(const basic_parsed_options<char>& options, 
diff --git a/libraries/boost/boost/serialization/detail/shared_ptr_132.hpp b/libraries/boost/boost/serialization/detail/shared_ptr_132.hpp
index b5f2b21..fe7a39d 100644
--- a/libraries/boost/boost/serialization/detail/shared_ptr_132.hpp
+++ b/libraries/boost/boost/serialization/detail/shared_ptr_132.hpp
@@ -2,7 +2,7 @@
 #define BOOST_SHARED_PTR_132_HPP_INCLUDED
 
 //
-//  shared_ptr.hpp
+//  boost::shared_ptr.hpp
 //
 //  (C) Copyright Greg Colvin and Beman Dawes 1998, 1999.
 //  Copyright (c) 2001, 2002, 2003 Peter Dimov
@@ -52,29 +52,29 @@ struct const_cast_tag {};
 struct dynamic_cast_tag {};
 struct polymorphic_cast_tag {};
 
-template<class T> struct shared_ptr_traits
+template<class T> struct boost::shared_ptr_traits
 {
     typedef T & reference;
 };
 
-template<> struct shared_ptr_traits<void>
+template<> struct boost::shared_ptr_traits<void>
 {
     typedef void reference;
 };
 
 #if !defined(BOOST_NO_CV_VOID_SPECIALIZATIONS)
 
-template<> struct shared_ptr_traits<void const>
+template<> struct boost::shared_ptr_traits<void const>
 {
     typedef void reference;
 };
 
-template<> struct shared_ptr_traits<void volatile>
+template<> struct boost::shared_ptr_traits<void volatile>
 {
     typedef void reference;
 };
 
-template<> struct shared_ptr_traits<void const volatile>
+template<> struct boost::shared_ptr_traits<void const volatile>
 {
     typedef void reference;
 };
@@ -96,18 +96,18 @@ inline void sp_enable_shared_from_this( shared_count const & /*pn*/, ... )
 
 
 //
-//  shared_ptr
+//  boost::shared_ptr
 //
 //  An enhanced relative of scoped_ptr with reference counted copy semantics.
-//  The object pointed to is deleted when the last shared_ptr pointing to it
+//  The object pointed to is deleted when the last boost::shared_ptr pointing to it
 //  is destroyed or reset.
 //
 
-template<class T> class shared_ptr
+template<class T> class boost::shared_ptr
 {
 private:
     // Borland 5.5.1 specific workaround
-    typedef shared_ptr< T > this_type;
+    typedef boost::shared_ptr< T > this_type;
 
 public:
 
@@ -116,16 +116,16 @@ public:
     typedef T * pointer;
     typedef BOOST_DEDUCED_TYPENAME detail::shared_ptr_traits< T >::reference reference;
 
-    shared_ptr(): px(0), pn() // never throws in 1.30+
+    boost::shared_ptr(): px(0), pn() // never throws in 1.30+
     {
     }
 
 #if BOOST_WORKAROUND( __BORLANDC__, BOOST_TESTED_AT( 0x564) )
     template<class Y>
-    explicit shared_ptr(Y * p): px(p), pn(p, boost::checked_deleter<Y>()) // Y must be complete
+    explicit boost::shared_ptr(Y * p): px(p), pn(p, boost::checked_deleter<Y>()) // Y must be complete
 #else
     template<class Y>
-    explicit shared_ptr(Y * p): px(p), pn(p, boost::checked_deleter<Y>()) // Y must be complete
+    explicit boost::shared_ptr(Y * p): px(p), pn(p, boost::checked_deleter<Y>()) // Y must be complete
 #endif
     {
         detail::sp_enable_shared_from_this( pn, p, p );
@@ -134,10 +134,10 @@ public:
     //
     // Requirements: D's copy constructor must not throw
     //
-    // shared_ptr will release p by calling d(p)
+    // boost::shared_ptr will release p by calling d(p)
     //
 
-    template<class Y, class D> shared_ptr(Y * p, D d): px(p), pn(p, d)
+    template<class Y, class D> boost::shared_ptr(Y * p, D d): px(p), pn(p, d)
     {
         detail::sp_enable_shared_from_this( pn, p, p );
     }
@@ -147,7 +147,7 @@ public:
 //  except that Borland C++ has a bug, and g++ with -Wsynth warns
 #if defined(__BORLANDC__) || defined(__GNUC__)
 
-    shared_ptr & operator=(shared_ptr const & r) // never throws
+    boost::shared_ptr & operator=(boost::shared_ptr const & r) // never throws
     {
         px = r.px;
         pn = r.pn; // shared_count::op= doesn't throw
@@ -157,29 +157,29 @@ public:
 #endif
 
     template<class Y>
-    explicit shared_ptr(weak_ptr<Y> const & r): pn(r.pn) // may throw
+    explicit boost::shared_ptr(weak_ptr<Y> const & r): pn(r.pn) // may throw
     {
         // it is now safe to copy r.px, as pn(r.pn) did not throw
         px = r.px;
     }
 
     template<class Y>
-    shared_ptr(shared_ptr<Y> const & r): px(r.px), pn(r.pn) // never throws
+    boost::shared_ptr(boost::shared_ptr<Y> const & r): px(r.px), pn(r.pn) // never throws
     {
     }
 
     template<class Y>
-    shared_ptr(shared_ptr<Y> const & r, detail::static_cast_tag): px(static_cast<element_type *>(r.px)), pn(r.pn)
+    boost::shared_ptr(boost::shared_ptr<Y> const & r, detail::static_cast_tag): px(static_cast<element_type *>(r.px)), pn(r.pn)
     {
     }
 
     template<class Y>
-    shared_ptr(shared_ptr<Y> const & r, detail::const_cast_tag): px(const_cast<element_type *>(r.px)), pn(r.pn)
+    boost::shared_ptr(boost::shared_ptr<Y> const & r, detail::const_cast_tag): px(const_cast<element_type *>(r.px)), pn(r.pn)
     {
     }
 
     template<class Y>
-    shared_ptr(shared_ptr<Y> const & r, detail::dynamic_cast_tag): px(dynamic_cast<element_type *>(r.px)), pn(r.pn)
+    boost::shared_ptr(boost::shared_ptr<Y> const & r, detail::dynamic_cast_tag): px(dynamic_cast<element_type *>(r.px)), pn(r.pn)
     {
         if(px == 0) // need to allocate new counter -- the cast failed
         {
@@ -188,7 +188,7 @@ public:
     }
 
     template<class Y>
-    shared_ptr(shared_ptr<Y> const & r, detail::polymorphic_cast_tag): px(dynamic_cast<element_type *>(r.px)), pn(r.pn)
+    boost::shared_ptr(boost::shared_ptr<Y> const & r, detail::polymorphic_cast_tag): px(dynamic_cast<element_type *>(r.px)), pn(r.pn)
     {
         if(px == 0)
         {
@@ -199,7 +199,7 @@ public:
 #ifndef BOOST_NO_AUTO_PTR
 
     template<class Y>
-    explicit shared_ptr(std::auto_ptr<Y> & r): px(r.get()), pn()
+    explicit boost::shared_ptr(std::auto_ptr<Y> & r): px(r.get()), pn()
     {
         Y * tmp = r.get();
         pn = detail::shared_count(r);
@@ -211,7 +211,7 @@ public:
 #if !defined(BOOST_MSVC) || (BOOST_MSVC > 1200)
 
     template<class Y>
-    shared_ptr & operator=(shared_ptr<Y> const & r) // never throws
+    boost::shared_ptr & operator=(boost::shared_ptr<Y> const & r) // never throws
     {
         px = r.px;
         pn = r.pn; // shared_count::op= doesn't throw
@@ -223,7 +223,7 @@ public:
 #ifndef BOOST_NO_AUTO_PTR
 
     template<class Y>
-    shared_ptr & operator=(std::auto_ptr<Y> & r)
+    boost::shared_ptr & operator=(std::auto_ptr<Y> & r)
     {
         this_type(r).swap(*this);
         return *this;
@@ -309,13 +309,13 @@ public:
         return pn.use_count();
     }
 
-    void swap(shared_ptr< T > & other) // never throws
+    void swap(boost::shared_ptr< T > & other) // never throws
     {
         std::swap(px, other.px);
         pn.swap(other.pn);
     }
 
-    template<class Y> bool _internal_less(shared_ptr<Y> const & rhs) const
+    template<class Y> bool _internal_less(boost::shared_ptr<Y> const & rhs) const
     {
         return pn < rhs.pn;
     }
@@ -332,7 +332,7 @@ public:
 
 private:
 
-    template<class Y> friend class shared_ptr;
+    template<class Y> friend class boost::shared_ptr;
     template<class Y> friend class weak_ptr;
 
 
@@ -341,14 +341,14 @@ public: // for serialization
     T * px;                     // contained pointer
     detail::shared_count pn;    // reference counter
 
-};  // shared_ptr
+};  // boost::shared_ptr
 
-template<class T, class U> inline bool operator==(shared_ptr< T > const & a, shared_ptr<U> const & b)
+template<class T, class U> inline bool operator==(boost::shared_ptr< T > const & a, boost::shared_ptr<U> const & b)
 {
     return a.get() == b.get();
 }
 
-template<class T, class U> inline bool operator!=(shared_ptr< T > const & a, shared_ptr<U> const & b)
+template<class T, class U> inline bool operator!=(boost::shared_ptr< T > const & a, boost::shared_ptr<U> const & b)
 {
     return a.get() != b.get();
 }
@@ -357,64 +357,64 @@ template<class T, class U> inline bool operator!=(shared_ptr< T > const & a, sha
 
 // Resolve the ambiguity between our op!= and the one in rel_ops
 
-template<class T> inline bool operator!=(shared_ptr< T > const & a, shared_ptr< T > const & b)
+template<class T> inline bool operator!=(boost::shared_ptr< T > const & a, boost::shared_ptr< T > const & b)
 {
     return a.get() != b.get();
 }
 
 #endif
 
-template<class T, class U> inline bool operator<(shared_ptr< T > const & a, shared_ptr<U> const & b)
+template<class T, class U> inline bool operator<(boost::shared_ptr< T > const & a, boost::shared_ptr<U> const & b)
 {
     return a._internal_less(b);
 }
 
-template<class T> inline void swap(shared_ptr< T > & a, shared_ptr< T > & b)
+template<class T> inline void swap(boost::shared_ptr< T > & a, boost::shared_ptr< T > & b)
 {
     a.swap(b);
 }
 
-template<class T, class U> shared_ptr< T > static_pointer_cast(shared_ptr<U> const & r)
+template<class T, class U> boost::shared_ptr< T > static_pointer_cast(boost::shared_ptr<U> const & r)
 {
-    return shared_ptr< T >(r, detail::static_cast_tag());
+    return boost::shared_ptr< T >(r, detail::static_cast_tag());
 }
 
-template<class T, class U> shared_ptr< T > const_pointer_cast(shared_ptr<U> const & r)
+template<class T, class U> boost::shared_ptr< T > const_pointer_cast(boost::shared_ptr<U> const & r)
 {
-    return shared_ptr< T >(r, detail::const_cast_tag());
+    return boost::shared_ptr< T >(r, detail::const_cast_tag());
 }
 
-template<class T, class U> shared_ptr< T > dynamic_pointer_cast(shared_ptr<U> const & r)
+template<class T, class U> boost::shared_ptr< T > dynamic_pointer_cast(boost::shared_ptr<U> const & r)
 {
-    return shared_ptr< T >(r, detail::dynamic_cast_tag());
+    return boost::shared_ptr< T >(r, detail::dynamic_cast_tag());
 }
 
 // shared_*_cast names are deprecated. Use *_pointer_cast instead.
 
-template<class T, class U> shared_ptr< T > shared_static_cast(shared_ptr<U> const & r)
+template<class T, class U> boost::shared_ptr< T > shared_static_cast(boost::shared_ptr<U> const & r)
 {
-    return shared_ptr< T >(r, detail::static_cast_tag());
+    return boost::shared_ptr< T >(r, detail::static_cast_tag());
 }
 
-template<class T, class U> shared_ptr< T > shared_dynamic_cast(shared_ptr<U> const & r)
+template<class T, class U> boost::shared_ptr< T > shared_dynamic_cast(boost::shared_ptr<U> const & r)
 {
-    return shared_ptr< T >(r, detail::dynamic_cast_tag());
+    return boost::shared_ptr< T >(r, detail::dynamic_cast_tag());
 }
 
-template<class T, class U> shared_ptr< T > shared_polymorphic_cast(shared_ptr<U> const & r)
+template<class T, class U> boost::shared_ptr< T > shared_polymorphic_cast(boost::shared_ptr<U> const & r)
 {
-    return shared_ptr< T >(r, detail::polymorphic_cast_tag());
+    return boost::shared_ptr< T >(r, detail::polymorphic_cast_tag());
 }
 
-template<class T, class U> shared_ptr< T > shared_polymorphic_downcast(shared_ptr<U> const & r)
+template<class T, class U> boost::shared_ptr< T > shared_polymorphic_downcast(boost::shared_ptr<U> const & r)
 {
     BOOST_ASSERT(dynamic_cast<T *>(r.get()) == r.get());
     return shared_static_cast< T >(r);
 }
 
-// get_pointer() enables boost::mem_fn to recognize shared_ptr
+// get_pointer() enables boost::mem_fn to recognize boost::shared_ptr
 
-template<class T> inline T * get_pointer(shared_ptr< T > const & p)
+template<class T> inline T * get_pointer(boost::shared_ptr< T > const & p)
 {
     return p.get();
 }
@@ -423,7 +423,7 @@ template<class T> inline T * get_pointer(shared_ptr< T > const & p)
 
 #if defined(__GNUC__) &&  (__GNUC__ < 3)
 
-template<class Y> std::ostream & operator<< (std::ostream & os, shared_ptr<Y> const & p)
+template<class Y> std::ostream & operator<< (std::ostream & os, boost::shared_ptr<Y> const & p)
 {
     os << p.get();
     return os;
@@ -434,9 +434,9 @@ template<class Y> std::ostream & operator<< (std::ostream & os, shared_ptr<Y> co
 # if defined(BOOST_MSVC) && BOOST_WORKAROUND(BOOST_MSVC, <= 1200 && __SGI_STL_PORT)
 // MSVC6 has problems finding std::basic_ostream through the using declaration in namespace _STL
 using std::basic_ostream;
-template<class E, class T, class Y> basic_ostream<E, T> & operator<< (basic_ostream<E, T> & os, shared_ptr<Y> const & p)
+template<class E, class T, class Y> basic_ostream<E, T> & operator<< (basic_ostream<E, T> & os, boost::shared_ptr<Y> const & p)
 # else
-template<class E, class T, class Y> std::basic_ostream<E, T> & operator<< (std::basic_ostream<E, T> & os, shared_ptr<Y> const & p)
+template<class E, class T, class Y> std::basic_ostream<E, T> & operator<< (std::basic_ostream<E, T> & os, boost::shared_ptr<Y> const & p)
 # endif 
 {
     os << p.get();
@@ -452,7 +452,7 @@ template<class E, class T, class Y> std::basic_ostream<E, T> & operator<< (std::
 // g++ 2.9x doesn't allow static_cast<X const *>(void *)
 // apparently EDG 2.38 also doesn't accept it
 
-template<class D, class T> D * get_deleter(shared_ptr< T > const & p)
+template<class D, class T> D * get_deleter(boost::shared_ptr< T > const & p)
 {
     void const * q = p._internal_get_deleter(typeid(D));
     return const_cast<D *>(static_cast<D const *>(q));
@@ -460,7 +460,7 @@ template<class D, class T> D * get_deleter(shared_ptr< T > const & p)
 
 #else
 
-template<class D, class T> D * get_deleter(shared_ptr< T > const & p)
+template<class D, class T> D * get_deleter(boost::shared_ptr< T > const & p)
 {
     return static_cast<D *>(p._internal_get_deleter(typeid(D)));
 }
diff --git a/libraries/boost/boost/serialization/detail/shared_ptr_nmt_132.hpp b/libraries/boost/boost/serialization/detail/shared_ptr_nmt_132.hpp
index 490e7dd..4f33ecc 100644
--- a/libraries/boost/boost/serialization/detail/shared_ptr_nmt_132.hpp
+++ b/libraries/boost/boost/serialization/detail/shared_ptr_nmt_132.hpp
@@ -2,7 +2,7 @@
 #define BOOST_DETAIL_SHARED_PTR_NMT_132_HPP_INCLUDED
 
 //
-//  detail/shared_ptr_nmt.hpp - shared_ptr.hpp without member templates
+//  detail/shared_ptr_nmt.hpp - boost::shared_ptr.hpp without member templates
 //
 //  (C) Copyright Greg Colvin and Beman Dawes 1998, 1999.
 //  Copyright (c) 2001, 2002 Peter Dimov
@@ -30,7 +30,7 @@
 namespace boost
 {
 
-template<class T> class shared_ptr
+template<class T> class boost::shared_ptr
 {
 private:
 
@@ -41,7 +41,7 @@ public:
     typedef T element_type;
     typedef T value_type;
 
-    explicit shared_ptr(T * p = 0): px(p)
+    explicit boost::shared_ptr(T * p = 0): px(p)
     {
 #ifndef BOOST_NO_EXCEPTIONS
 
@@ -77,29 +77,29 @@ public:
         }
     }
 
-    shared_ptr(shared_ptr const & r): px(r.px)  // never throws
+    boost::shared_ptr(boost::shared_ptr const & r): px(r.px)  // never throws
     {
         pn = r.pn;
         ++*pn;
     }
 
-    shared_ptr & operator=(shared_ptr const & r)
+    boost::shared_ptr & operator=(boost::shared_ptr const & r)
     {
-        shared_ptr(r).swap(*this);
+        boost::shared_ptr(r).swap(*this);
         return *this;
     }
 
 #ifndef BOOST_NO_AUTO_PTR
 
-    explicit shared_ptr(std::auto_ptr< T > & r)
+    explicit boost::shared_ptr(std::auto_ptr< T > & r)
     { 
         pn = new count_type(1); // may throw
         px = r.release(); // fix: moved here to stop leak if new throws
     } 
 
-    shared_ptr & operator=(std::auto_ptr< T > & r)
+    boost::shared_ptr & operator=(std::auto_ptr< T > & r)
     {
-        shared_ptr(r).swap(*this);
+        boost::shared_ptr(r).swap(*this);
         return *this;
     }
 
@@ -108,7 +108,7 @@ public:
     void reset(T * p = 0)
     {
         BOOST_ASSERT(p == 0 || p != px);
-        shared_ptr(p).swap(*this);
+        boost::shared_ptr(p).swap(*this);
     }
 
     T & operator*() const  // never throws
@@ -138,7 +138,7 @@ public:
         return *pn == 1;
     }
     
-    void swap(shared_ptr< T > & other)  // never throws
+    void swap(boost::shared_ptr< T > & other)  // never throws
     {
         std::swap(px, other.px);
         std::swap(pn, other.pn);
@@ -150,29 +150,29 @@ private:
     count_type * pn;   // ptr to reference counter
 };
 
-template<class T, class U> inline bool operator==(shared_ptr< T > const & a, shared_ptr<U> const & b)
+template<class T, class U> inline bool operator==(boost::shared_ptr< T > const & a, boost::shared_ptr<U> const & b)
 {
     return a.get() == b.get();
 }
 
-template<class T, class U> inline bool operator!=(shared_ptr< T > const & a, shared_ptr<U> const & b)
+template<class T, class U> inline bool operator!=(boost::shared_ptr< T > const & a, boost::shared_ptr<U> const & b)
 {
     return a.get() != b.get();
 }
 
-template<class T> inline bool operator<(shared_ptr< T > const & a, shared_ptr< T > const & b)
+template<class T> inline bool operator<(boost::shared_ptr< T > const & a, boost::shared_ptr< T > const & b)
 {
     return std::less<T*>()(a.get(), b.get());
 }
 
-template<class T> void swap(shared_ptr< T > & a, shared_ptr< T > & b)
+template<class T> void swap(boost::shared_ptr< T > & a, boost::shared_ptr< T > & b)
 {
     a.swap(b);
 }
 
-// get_pointer() enables boost::mem_fn to recognize shared_ptr
+// get_pointer() enables boost::mem_fn to recognize boost::shared_ptr
 
-template<class T> inline T * get_pointer(shared_ptr< T > const & p)
+template<class T> inline T * get_pointer(boost::shared_ptr< T > const & p)
 {
     return p.get();
 }
diff --git a/libraries/boost/boost/serialization/shared_ptr.hpp b/libraries/boost/boost/serialization/shared_ptr.hpp
index 37f95e3..6fafd14 100644
--- a/libraries/boost/boost/serialization/shared_ptr.hpp
+++ b/libraries/boost/boost/serialization/shared_ptr.hpp
@@ -7,7 +7,7 @@
 #endif
 
 /////////1/////////2/////////3/////////4/////////5/////////6/////////7/////////8
-// shared_ptr.hpp: serialization for boost shared pointer
+// boost::shared_ptr.hpp: serialization for boost shared pointer
 
 // (C) Copyright 2004 Robert Ramey and Martin Ecker
 // Use, modification and distribution is subject to the Boost Software
@@ -31,7 +31,7 @@
 #include <boost/serialization/tracking.hpp>
 
 /////////1/////////2/////////3/////////4/////////5/////////6/////////7/////////8
-// shared_ptr serialization traits
+// boost::shared_ptr serialization traits
 // version 1 to distinguish from boost 1.32 version. Note: we can only do this
 // for a template when the compiler supports partial template specialization
 
@@ -91,7 +91,7 @@ struct null_deleter {
 };
 
 /////////1/////////2/////////3/////////4/////////5/////////6/////////7/////////8
-// serialization for shared_ptr
+// serialization for boost::shared_ptr
 
 template<class Archive, class T>
 inline void save(
@@ -100,7 +100,7 @@ inline void save(
     const unsigned int /* file_version */
 ){
     // The most common cause of trapping here would be serializing
-    // something like shared_ptr<int>.  This occurs because int
+    // something like boost::shared_ptr<int>.  This occurs because int
     // is never tracked by default.  Wrap int in a trackable type
     BOOST_STATIC_ASSERT((tracking_level< T >::value != track_never));
     const T * t_ptr = t.get();
@@ -115,7 +115,7 @@ inline void load(
     const unsigned int file_version
 ){
     // The most common cause of trapping here would be serializing
-    // something like shared_ptr<int>.  This occurs because int
+    // something like boost::shared_ptr<int>.  This occurs because int
     // is never tracked by default.  Wrap int in a trackable type
     BOOST_STATIC_ASSERT((tracking_level< T >::value != track_never));
     T* r;
@@ -147,7 +147,7 @@ inline void load(
     const unsigned int /*file_version*/
 ){
     // The most common cause of trapping here would be serializing
-    // something like shared_ptr<int>.  This occurs because int
+    // something like boost::shared_ptr<int>.  This occurs because int
     // is never tracked by default.  Wrap int in a trackable type
     BOOST_STATIC_ASSERT((tracking_level< T >::value != track_never));
     T* r;
@@ -162,7 +162,7 @@ inline void serialize(
     boost::shared_ptr< T > &t,
     const unsigned int file_version
 ){
-    // correct shared_ptr serialization depends upon object tracking
+    // correct boost::shared_ptr serialization depends upon object tracking
     // being used.
     BOOST_STATIC_ASSERT(
         boost::serialization::tracking_level< T >::value
diff --git a/libraries/boost/boost/serialization/shared_ptr_132.hpp b/libraries/boost/boost/serialization/shared_ptr_132.hpp
index 9bcefe0..555f15d 100644
--- a/libraries/boost/boost/serialization/shared_ptr_132.hpp
+++ b/libraries/boost/boost/serialization/shared_ptr_132.hpp
@@ -7,7 +7,7 @@
 #endif
 
 /////////1/////////2/////////3/////////4/////////5/////////6/////////7/////////8
-// shared_ptr.hpp: serialization for boost shared pointer
+// boost::shared_ptr.hpp: serialization for boost shared pointer
 
 // (C) Copyright 2002 Robert Ramey - http://www.rrsd.com . 
 // Use, modification and distribution is subject to the Boost Software
@@ -17,8 +17,8 @@
 //  See http://www.boost.org for updates, documentation, and revision history.
 
 // note: totally unadvised hack to gain access to private variables
-// in shared_ptr and shared_count. Unfortunately its the only way to
-// do this without changing shared_ptr and shared_count
+// in boost::shared_ptr and shared_count. Unfortunately its the only way to
+// do this without changing boost::shared_ptr and shared_count
 // the best we can do is to detect a conflict here
 #include <boost/config.hpp>
 
@@ -96,7 +96,7 @@ inline void load_construct_data(
     // placement
     // note: the original ::new... above is replaced by the one here.  This one
     // creates all new objects with a null_deleter so that after the archive
-    // is finished loading and the shared_ptrs are destroyed - the underlying
+    // is finished loading and the boost::shared_ptrs are destroyed - the underlying
     // raw pointers are NOT deleted.  This is necessary as they are used by the 
     // new system as well.
     ::new(t)boost_132::detail::sp_counted_base_impl<
@@ -147,7 +147,7 @@ inline void load(
 BOOST_SERIALIZATION_SPLIT_FREE(boost_132::detail::shared_count)
 
 /////////////////////////////////////////////////////////////
-// implement serialization for shared_ptr< T >
+// implement serialization for boost::shared_ptr< T >
 
 namespace boost { 
 namespace serialization {
@@ -188,7 +188,7 @@ inline void serialize(
     boost_132::shared_ptr< T > &t,
     const unsigned int file_version
 ){
-    // correct shared_ptr serialization depends upon object tracking
+    // correct boost::shared_ptr serialization depends upon object tracking
     // being used.
     BOOST_STATIC_ASSERT(
         boost::serialization::tracking_level< T >::value
diff --git a/libraries/boost/boost/serialization/weak_ptr.hpp b/libraries/boost/boost/serialization/weak_ptr.hpp
index 3fe8698..172ad61 100644
--- a/libraries/boost/boost/serialization/weak_ptr.hpp
+++ b/libraries/boost/boost/serialization/weak_ptr.hpp
@@ -7,7 +7,7 @@
 #endif
 
 /////////1/////////2/////////3/////////4/////////5/////////6/////////7/////////8
-// shared_ptr.hpp: serialization for boost shared pointer
+// boost::shared_ptr.hpp: serialization for boost shared pointer
 
 // (C) Copyright 2004 Robert Ramey and Martin Ecker
 // Use, modification and distribution is subject to the Boost Software
diff --git a/libraries/boost/boost/shared_ptr.hpp b/libraries/boost/boost/shared_ptr.hpp
index d31978c..1bcfc9e 100644
--- a/libraries/boost/boost/shared_ptr.hpp
+++ b/libraries/boost/boost/shared_ptr.hpp
@@ -2,7 +2,7 @@
 #define BOOST_SHARED_PTR_HPP_INCLUDED
 
 //
-//  shared_ptr.hpp
+//  boost::shared_ptr.hpp
 //
 //  (C) Copyright Greg Colvin and Beman Dawes 1998, 1999.
 //  Copyright (c) 2001-2008 Peter Dimov
diff --git a/libraries/boost/boost/signals/connection.hpp b/libraries/boost/boost/signals/connection.hpp
index 48493aa..0a1efa9 100644
--- a/libraries/boost/boost/signals/connection.hpp
+++ b/libraries/boost/boost/signals/connection.hpp
@@ -97,7 +97,7 @@ namespace boost {
       void set_controlling(bool control = true)
       { controlling_connection = control; }
 
-      shared_ptr<BOOST_SIGNALS_NAMESPACE::detail::basic_connection>
+      boost::shared_ptr<BOOST_SIGNALS_NAMESPACE::detail::basic_connection>
       get_connection() const
       { return con; }
 
@@ -115,7 +115,7 @@ namespace boost {
       friend class BOOST_SIGNALS_NAMESPACE::detail::bound_objects_visitor;
 
       // Pointer to the actual contents of the connection
-      shared_ptr<BOOST_SIGNALS_NAMESPACE::detail::basic_connection> con;
+      boost::shared_ptr<BOOST_SIGNALS_NAMESPACE::detail::basic_connection> con;
 
       // True if the destruction of this connection object should disconnect
       bool controlling_connection;
diff --git a/libraries/boost/boost/signals/detail/named_slot_map.hpp b/libraries/boost/boost/signals/detail/named_slot_map.hpp
index 0528c61..24196a0 100644
--- a/libraries/boost/boost/signals/detail/named_slot_map.hpp
+++ b/libraries/boost/boost/signals/detail/named_slot_map.hpp
@@ -45,7 +45,7 @@ class stored_group
 
  private:
   storage_kind kind;
-  shared_ptr<void> group;
+  boost::shared_ptr<void> group;
 };
 
 typedef function2<bool, stored_group, stored_group> compare_type;
diff --git a/libraries/boost/boost/signals/detail/signal_base.hpp b/libraries/boost/boost/signals/detail/signal_base.hpp
index 0438cf7..b84ef07 100644
--- a/libraries/boost/boost/signals/detail/signal_base.hpp
+++ b/libraries/boost/boost/signals/detail/signal_base.hpp
@@ -33,10 +33,10 @@ namespace boost {
       // manages call depth
       class BOOST_SIGNALS_DECL call_notification {
       public:
-        call_notification(const shared_ptr<signal_base_impl>&);
+        call_notification(const boost::shared_ptr<signal_base_impl>&);
         ~call_notification();
 
-        shared_ptr<signal_base_impl> impl;
+        boost::shared_ptr<signal_base_impl> impl;
       };
 
       // Implementation of base class for all signals. It handles the
@@ -87,7 +87,7 @@ namespace boost {
 
         connection connect_slot(const any& slot,
                                 const stored_group& name,
-                                shared_ptr<slot_base::data_t> data,
+                                boost::shared_ptr<slot_base::data_t> data,
                                 connect_position at);
 
       private:
@@ -138,7 +138,7 @@ namespace boost {
       protected:
         connection connect_slot(const any& slot,
                                 const stored_group& name,
-                                shared_ptr<slot_base::data_t> data,
+                                boost::shared_ptr<slot_base::data_t> data,
                                 connect_position at)
         {
           return impl->connect_slot(slot, name, data, at);
@@ -146,7 +146,7 @@ namespace boost {
 
         typedef named_slot_map::iterator iterator;
 
-        shared_ptr<signal_base_impl> impl;
+        boost::shared_ptr<signal_base_impl> impl;
       };
     } // end namespace detail
   } // end namespace BOOST_SIGNALS_NAMESPACE
diff --git a/libraries/boost/boost/signals/slot.hpp b/libraries/boost/boost/signals/slot.hpp
index bbf1848..081fbb0 100644
--- a/libraries/boost/boost/signals/slot.hpp
+++ b/libraries/boost/boost/signals/slot.hpp
@@ -33,7 +33,7 @@ namespace boost {
           std::vector<const trackable*> bound_objects;
           connection watch_bound_objects;
         };
-        shared_ptr<data_t> get_data() const { return data; }
+        boost::shared_ptr<data_t> get_data() const { return data; }
 
         // Get the set of bound objects
         std::vector<const trackable*>& get_bound_objects() const
@@ -48,7 +48,7 @@ namespace boost {
         // Create a connection for this slot
         void create_connection();
 
-        shared_ptr<data_t> data;
+        boost::shared_ptr<data_t> data;
 
       private:
         static void bound_object_destructed(void*, void*) {}
diff --git a/libraries/boost/boost/smart_ptr/detail/shared_ptr_nmt.hpp b/libraries/boost/boost/smart_ptr/detail/shared_ptr_nmt.hpp
index afc1ec0..35e7421 100644
--- a/libraries/boost/boost/smart_ptr/detail/shared_ptr_nmt.hpp
+++ b/libraries/boost/boost/smart_ptr/detail/shared_ptr_nmt.hpp
@@ -2,7 +2,7 @@
 #define BOOST_SMART_PTR_DETAIL_SHARED_PTR_NMT_HPP_INCLUDED
 
 //
-//  detail/shared_ptr_nmt.hpp - shared_ptr.hpp without member templates
+//  detail/shared_ptr_nmt.hpp - boost::shared_ptr.hpp without member templates
 //
 //  (C) Copyright Greg Colvin and Beman Dawes 1998, 1999.
 //  Copyright (c) 2001, 2002 Peter Dimov
@@ -30,7 +30,7 @@
 namespace boost
 {
 
-template<class T> class shared_ptr
+template<class T> class boost::shared_ptr
 {
 private:
 
@@ -41,7 +41,7 @@ public:
     typedef T element_type;
     typedef T value_type;
 
-    explicit shared_ptr(T * p = 0): px(p)
+    explicit boost::shared_ptr(T * p = 0): px(p)
     {
 #ifndef BOOST_NO_EXCEPTIONS
 
@@ -77,29 +77,29 @@ public:
         }
     }
 
-    shared_ptr(shared_ptr const & r): px(r.px)  // never throws
+    boost::shared_ptr(boost::shared_ptr const & r): px(r.px)  // never throws
     {
         pn = r.pn;
         ++*pn;
     }
 
-    shared_ptr & operator=(shared_ptr const & r)
+    boost::shared_ptr & operator=(boost::shared_ptr const & r)
     {
-        shared_ptr(r).swap(*this);
+        boost::shared_ptr(r).swap(*this);
         return *this;
     }
 
 #ifndef BOOST_NO_AUTO_PTR
 
-    explicit shared_ptr(std::auto_ptr<T> & r)
+    explicit boost::shared_ptr(std::auto_ptr<T> & r)
     { 
         pn = new count_type(1); // may throw
         px = r.release(); // fix: moved here to stop leak if new throws
     } 
 
-    shared_ptr & operator=(std::auto_ptr<T> & r)
+    boost::shared_ptr & operator=(std::auto_ptr<T> & r)
     {
-        shared_ptr(r).swap(*this);
+        boost::shared_ptr(r).swap(*this);
         return *this;
     }
 
@@ -108,7 +108,7 @@ public:
     void reset(T * p = 0)
     {
         BOOST_ASSERT(p == 0 || p != px);
-        shared_ptr(p).swap(*this);
+        boost::shared_ptr(p).swap(*this);
     }
 
     T & operator*() const  // never throws
@@ -138,7 +138,7 @@ public:
         return *pn == 1;
     }
     
-    void swap(shared_ptr<T> & other)  // never throws
+    void swap(boost::shared_ptr<T> & other)  // never throws
     {
         std::swap(px, other.px);
         std::swap(pn, other.pn);
@@ -150,29 +150,29 @@ private:
     count_type * pn;   // ptr to reference counter
 };
 
-template<class T, class U> inline bool operator==(shared_ptr<T> const & a, shared_ptr<U> const & b)
+template<class T, class U> inline bool operator==(boost::shared_ptr<T> const & a, boost::shared_ptr<U> const & b)
 {
     return a.get() == b.get();
 }
 
-template<class T, class U> inline bool operator!=(shared_ptr<T> const & a, shared_ptr<U> const & b)
+template<class T, class U> inline bool operator!=(boost::shared_ptr<T> const & a, boost::shared_ptr<U> const & b)
 {
     return a.get() != b.get();
 }
 
-template<class T> inline bool operator<(shared_ptr<T> const & a, shared_ptr<T> const & b)
+template<class T> inline bool operator<(boost::shared_ptr<T> const & a, boost::shared_ptr<T> const & b)
 {
     return std::less<T*>()(a.get(), b.get());
 }
 
-template<class T> void swap(shared_ptr<T> & a, shared_ptr<T> & b)
+template<class T> void swap(boost::shared_ptr<T> & a, boost::shared_ptr<T> & b)
 {
     a.swap(b);
 }
 
-// get_pointer() enables boost::mem_fn to recognize shared_ptr
+// get_pointer() enables boost::mem_fn to recognize boost::shared_ptr
 
-template<class T> inline T * get_pointer(shared_ptr<T> const & p)
+template<class T> inline T * get_pointer(boost::shared_ptr<T> const & p)
 {
     return p.get();
 }
diff --git a/libraries/boost/boost/smart_ptr/detail/spinlock_pool.hpp b/libraries/boost/boost/smart_ptr/detail/spinlock_pool.hpp
index 0e2e08a..b41c7f4 100644
--- a/libraries/boost/boost/smart_ptr/detail/spinlock_pool.hpp
+++ b/libraries/boost/boost/smart_ptr/detail/spinlock_pool.hpp
@@ -17,8 +17,8 @@
 //  http://www.boost.org/LICENSE_1_0.txt)
 //
 //  spinlock_pool<0> is reserved for atomic<>, when/if it arrives
-//  spinlock_pool<1> is reserved for shared_ptr reference counts
-//  spinlock_pool<2> is reserved for shared_ptr atomic access
+//  spinlock_pool<1> is reserved for boost::shared_ptr reference counts
+//  spinlock_pool<2> is reserved for boost::shared_ptr atomic access
 //
 
 #include <boost/config.hpp>
diff --git a/libraries/boost/boost/smart_ptr/enable_shared_from_this.hpp b/libraries/boost/boost/smart_ptr/enable_shared_from_this.hpp
index f7b1445..285782b 100644
--- a/libraries/boost/boost/smart_ptr/enable_shared_from_this.hpp
+++ b/libraries/boost/boost/smart_ptr/enable_shared_from_this.hpp
@@ -44,28 +44,28 @@ protected:
 
 public:
 
-    shared_ptr<T> shared_from_this()
+    boost::shared_ptr<T> shared_from_this()
     {
-        shared_ptr<T> p( weak_this_ );
+        boost::shared_ptr<T> p( weak_this_ );
         BOOST_ASSERT( p.get() == this );
         return p;
     }
 
-    shared_ptr<T const> shared_from_this() const
+    boost::shared_ptr<T const> shared_from_this() const
     {
-        shared_ptr<T const> p( weak_this_ );
+        boost::shared_ptr<T const> p( weak_this_ );
         BOOST_ASSERT( p.get() == this );
         return p;
     }
 
 public: // actually private, but avoids compiler template friendship issues
 
-    // Note: invoked automatically by shared_ptr; do not call
-    template<class X, class Y> void _internal_accept_owner( shared_ptr<X> const * ppx, Y * py ) const
+    // Note: invoked automatically by boost::shared_ptr; do not call
+    template<class X, class Y> void _internal_accept_owner( boost::shared_ptr<X> const * ppx, Y * py ) const
     {
         if( weak_this_.expired() )
         {
-            weak_this_ = shared_ptr<T>( *ppx, py );
+            weak_this_ = boost::shared_ptr<T>( *ppx, py );
         }
     }
 
diff --git a/libraries/boost/boost/smart_ptr/enable_shared_from_this2.hpp b/libraries/boost/boost/smart_ptr/enable_shared_from_this2.hpp
index a5bfcff..6c0dc93 100644
--- a/libraries/boost/boost/smart_ptr/enable_shared_from_this2.hpp
+++ b/libraries/boost/boost/smart_ptr/enable_shared_from_this2.hpp
@@ -27,7 +27,7 @@ class esft2_deleter_wrapper
 {
 private:
 
-    shared_ptr<void> deleter_;
+    boost::shared_ptr<void> deleter_;
 
 public:
 
@@ -35,7 +35,7 @@ public:
     {
     }
 
-    template< class T > void set_deleter( shared_ptr<T> const & deleter )
+    template< class T > void set_deleter( boost::shared_ptr<T> const & deleter )
     {
         deleter_ = deleter;
     }
@@ -68,26 +68,26 @@ protected:
 
     ~enable_shared_from_this2()
     {
-        BOOST_ASSERT( shared_this_.use_count() <= 1 ); // make sure no dangling shared_ptr objects exist
+        BOOST_ASSERT( shared_this_.use_count() <= 1 ); // make sure no dangling boost::shared_ptr objects exist
     }
 
 private:
 
     mutable weak_ptr<T> weak_this_;
-    mutable shared_ptr<T> shared_this_;
+    mutable boost::shared_ptr<T> shared_this_;
 
 public:
 
-    shared_ptr<T> shared_from_this()
+    boost::shared_ptr<T> shared_from_this()
     {
         init_weak_once();
-        return shared_ptr<T>( weak_this_ );
+        return boost::shared_ptr<T>( weak_this_ );
     }
 
-    shared_ptr<T const> shared_from_this() const
+    boost::shared_ptr<T const> shared_from_this() const
     {
         init_weak_once();
-        return shared_ptr<T>( weak_this_ );
+        return boost::shared_ptr<T>( weak_this_ );
     }
 
 private:
@@ -103,14 +103,14 @@ private:
 
 public: // actually private, but avoids compiler template friendship issues
 
-    // Note: invoked automatically by shared_ptr; do not call
-    template<class X, class Y> void _internal_accept_owner( shared_ptr<X> * ppx, Y * py ) const
+    // Note: invoked automatically by boost::shared_ptr; do not call
+    template<class X, class Y> void _internal_accept_owner( boost::shared_ptr<X> * ppx, Y * py ) const
     {
         BOOST_ASSERT( ppx != 0 );
 
         if( weak_this_.use_count() == 0 )
         {
-            weak_this_ = shared_ptr<T>( *ppx, py );
+            weak_this_ = boost::shared_ptr<T>( *ppx, py );
         }
         else if( shared_this_.use_count() != 0 )
         {
diff --git a/libraries/boost/boost/smart_ptr/scoped_ptr.hpp b/libraries/boost/boost/smart_ptr/scoped_ptr.hpp
index df479e5..60dcd7a 100644
--- a/libraries/boost/boost/smart_ptr/scoped_ptr.hpp
+++ b/libraries/boost/boost/smart_ptr/scoped_ptr.hpp
@@ -34,7 +34,7 @@ void sp_scalar_destructor_hook(void * p);
 //  scoped_ptr mimics a built-in pointer except that it guarantees deletion
 //  of the object pointed to, either on destruction of the scoped_ptr or via
 //  an explicit reset(). scoped_ptr is a simple solution for simple needs;
-//  use shared_ptr or std::auto_ptr if your needs are more complex.
+//  use boost::shared_ptr or std::auto_ptr if your needs are more complex.
 
 template<class T> class scoped_ptr // noncopyable
 {
diff --git a/libraries/boost/boost/smart_ptr/shared_array.hpp b/libraries/boost/boost/smart_ptr/shared_array.hpp
index 1f50403..e658f97 100644
--- a/libraries/boost/boost/smart_ptr/shared_array.hpp
+++ b/libraries/boost/boost/smart_ptr/shared_array.hpp
@@ -38,7 +38,7 @@ namespace boost
 //
 //  shared_array
 //
-//  shared_array extends shared_ptr to arrays.
+//  shared_array extends boost::shared_ptr to arrays.
 //  The array pointed to is deleted when the last shared_array pointing to it
 //  is destroyed or reset.
 //
diff --git a/libraries/boost/boost/smart_ptr/shared_ptr.hpp b/libraries/boost/boost/smart_ptr/shared_ptr.hpp
index 609cce9..92afee4 100644
--- a/libraries/boost/boost/smart_ptr/shared_ptr.hpp
+++ b/libraries/boost/boost/smart_ptr/shared_ptr.hpp
@@ -2,7 +2,7 @@
 #define BOOST_SMART_PTR_SHARED_PTR_HPP_INCLUDED
 
 //
-//  shared_ptr.hpp
+//  boost::shared_ptr.hpp
 //
 //  (C) Copyright Greg Colvin and Beman Dawes 1998, 1999.
 //  Copyright (c) 2001-2008 Peter Dimov
@@ -58,7 +58,7 @@
 namespace boost
 {
 
-template<class T> class shared_ptr;
+template<class T> class boost::shared_ptr;
 template<class T> class weak_ptr;
 template<class T> class enable_shared_from_this;
 template<class T> class enable_shared_from_this2;
@@ -71,29 +71,29 @@ struct const_cast_tag {};
 struct dynamic_cast_tag {};
 struct polymorphic_cast_tag {};
 
-template<class T> struct shared_ptr_traits
+template<class T> struct boost::shared_ptr_traits
 {
     typedef T & reference;
 };
 
-template<> struct shared_ptr_traits<void>
+template<> struct boost::shared_ptr_traits<void>
 {
     typedef void reference;
 };
 
 #if !defined(BOOST_NO_CV_VOID_SPECIALIZATIONS)
 
-template<> struct shared_ptr_traits<void const>
+template<> struct boost::shared_ptr_traits<void const>
 {
     typedef void reference;
 };
 
-template<> struct shared_ptr_traits<void volatile>
+template<> struct boost::shared_ptr_traits<void volatile>
 {
     typedef void reference;
 };
 
-template<> struct shared_ptr_traits<void const volatile>
+template<> struct boost::shared_ptr_traits<void const volatile>
 {
     typedef void reference;
 };
@@ -158,19 +158,19 @@ template< class T, class R > struct sp_enable_if_auto_ptr< std::auto_ptr< T >, R
 
 
 //
-//  shared_ptr
+//  boost::shared_ptr
 //
 //  An enhanced relative of scoped_ptr with reference counted copy semantics.
-//  The object pointed to is deleted when the last shared_ptr pointing to it
+//  The object pointed to is deleted when the last boost::shared_ptr pointing to it
 //  is destroyed or reset.
 //
 
-template<class T> class shared_ptr
+template<class T> class boost::shared_ptr
 {
 private:
 
     // Borland 5.5.1 specific workaround
-    typedef shared_ptr<T> this_type;
+    typedef boost::shared_ptr<T> this_type;
 
 public:
 
@@ -179,12 +179,12 @@ public:
     typedef T * pointer;
     typedef typename boost::detail::shared_ptr_traits<T>::reference reference;
 
-    shared_ptr(): px(0), pn() // never throws in 1.30+
+    boost::shared_ptr(): px(0), pn() // never throws in 1.30+
     {
     }
 
     template<class Y>
-    explicit shared_ptr( Y * p ): px( p ), pn( p ) // Y must be complete
+    explicit boost::shared_ptr( Y * p ): px( p ), pn( p ) // Y must be complete
     {
         boost::detail::sp_enable_shared_from_this( this, p, p );
     }
@@ -192,17 +192,17 @@ public:
     //
     // Requirements: D's copy constructor must not throw
     //
-    // shared_ptr will release p by calling d(p)
+    // boost::shared_ptr will release p by calling d(p)
     //
 
-    template<class Y, class D> shared_ptr(Y * p, D d): px(p), pn(p, d)
+    template<class Y, class D> boost::shared_ptr(Y * p, D d): px(p), pn(p, d)
     {
         boost::detail::sp_enable_shared_from_this( this, p, p );
     }
 
     // As above, but with allocator. A's copy constructor shall not throw.
 
-    template<class Y, class D, class A> shared_ptr( Y * p, D d, A a ): px( p ), pn( p, d, a )
+    template<class Y, class D, class A> boost::shared_ptr( Y * p, D d, A a ): px( p ), pn( p, d, a )
     {
         boost::detail::sp_enable_shared_from_this( this, p, p );
     }
@@ -210,14 +210,14 @@ public:
 //  generated copy constructor, destructor are fine
 
     template<class Y>
-    explicit shared_ptr(weak_ptr<Y> const & r): pn(r.pn) // may throw
+    explicit boost::shared_ptr(weak_ptr<Y> const & r): pn(r.pn) // may throw
     {
         // it is now safe to copy r.px, as pn(r.pn) did not throw
         px = r.px;
     }
 
     template<class Y>
-    shared_ptr( weak_ptr<Y> const & r, boost::detail::sp_nothrow_tag ): px( 0 ), pn( r.pn, boost::detail::sp_nothrow_tag() ) // never throws
+    boost::shared_ptr( weak_ptr<Y> const & r, boost::detail::sp_nothrow_tag ): px( 0 ), pn( r.pn, boost::detail::sp_nothrow_tag() ) // never throws
     {
         if( !pn.empty() )
         {
@@ -228,11 +228,11 @@ public:
     template<class Y>
 #if !defined( BOOST_SP_NO_SP_CONVERTIBLE )
 
-    shared_ptr( shared_ptr<Y> const & r, typename boost::detail::sp_enable_if_convertible<Y,T>::type = boost::detail::sp_empty() )
+    boost::shared_ptr( boost::shared_ptr<Y> const & r, typename boost::detail::sp_enable_if_convertible<Y,T>::type = boost::detail::sp_empty() )
 
 #else
 
-    shared_ptr( shared_ptr<Y> const & r )
+    boost::shared_ptr( boost::shared_ptr<Y> const & r )
 
 #endif
     : px( r.px ), pn( r.pn ) // never throws
@@ -241,22 +241,22 @@ public:
 
     // aliasing
     template< class Y >
-    shared_ptr( shared_ptr<Y> const & r, T * p ): px( p ), pn( r.pn ) // never throws
+    boost::shared_ptr( boost::shared_ptr<Y> const & r, T * p ): px( p ), pn( r.pn ) // never throws
     {
     }
 
     template<class Y>
-    shared_ptr(shared_ptr<Y> const & r, boost::detail::static_cast_tag): px(static_cast<element_type *>(r.px)), pn(r.pn)
+    boost::shared_ptr(boost::shared_ptr<Y> const & r, boost::detail::static_cast_tag): px(static_cast<element_type *>(r.px)), pn(r.pn)
     {
     }
 
     template<class Y>
-    shared_ptr(shared_ptr<Y> const & r, boost::detail::const_cast_tag): px(const_cast<element_type *>(r.px)), pn(r.pn)
+    boost::shared_ptr(boost::shared_ptr<Y> const & r, boost::detail::const_cast_tag): px(const_cast<element_type *>(r.px)), pn(r.pn)
     {
     }
 
     template<class Y>
-    shared_ptr(shared_ptr<Y> const & r, boost::detail::dynamic_cast_tag): px(dynamic_cast<element_type *>(r.px)), pn(r.pn)
+    boost::shared_ptr(boost::shared_ptr<Y> const & r, boost::detail::dynamic_cast_tag): px(dynamic_cast<element_type *>(r.px)), pn(r.pn)
     {
         if(px == 0) // need to allocate new counter -- the cast failed
         {
@@ -265,7 +265,7 @@ public:
     }
 
     template<class Y>
-    shared_ptr(shared_ptr<Y> const & r, boost::detail::polymorphic_cast_tag): px(dynamic_cast<element_type *>(r.px)), pn(r.pn)
+    boost::shared_ptr(boost::shared_ptr<Y> const & r, boost::detail::polymorphic_cast_tag): px(dynamic_cast<element_type *>(r.px)), pn(r.pn)
     {
         if(px == 0)
         {
@@ -276,7 +276,7 @@ public:
 #ifndef BOOST_NO_AUTO_PTR
 
     template<class Y>
-    explicit shared_ptr(std::auto_ptr<Y> & r): px(r.get()), pn()
+    explicit boost::shared_ptr(std::auto_ptr<Y> & r): px(r.get()), pn()
     {
         Y * tmp = r.get();
         pn = boost::detail::shared_count(r);
@@ -286,7 +286,7 @@ public:
 #if !defined( BOOST_NO_SFINAE ) && !defined( BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION )
 
     template<class Ap>
-    explicit shared_ptr( Ap r, typename boost::detail::sp_enable_if_auto_ptr<Ap, int>::type = 0 ): px( r.get() ), pn()
+    explicit boost::shared_ptr( Ap r, typename boost::detail::sp_enable_if_auto_ptr<Ap, int>::type = 0 ): px( r.get() ), pn()
     {
         typename Ap::element_type * tmp = r.get();
         pn = boost::detail::shared_count( r );
@@ -300,7 +300,7 @@ public:
 
     // assignment
 
-    shared_ptr & operator=( shared_ptr const & r ) // never throws
+    boost::shared_ptr & operator=( boost::shared_ptr const & r ) // never throws
     {
         this_type(r).swap(*this);
         return *this;
@@ -309,7 +309,7 @@ public:
 #if !defined(BOOST_MSVC) || (BOOST_MSVC >= 1400)
 
     template<class Y>
-    shared_ptr & operator=(shared_ptr<Y> const & r) // never throws
+    boost::shared_ptr & operator=(boost::shared_ptr<Y> const & r) // never throws
     {
         this_type(r).swap(*this);
         return *this;
@@ -320,7 +320,7 @@ public:
 #ifndef BOOST_NO_AUTO_PTR
 
     template<class Y>
-    shared_ptr & operator=( std::auto_ptr<Y> & r )
+    boost::shared_ptr & operator=( std::auto_ptr<Y> & r )
     {
         this_type(r).swap(*this);
         return *this;
@@ -329,7 +329,7 @@ public:
 #if !defined( BOOST_NO_SFINAE ) && !defined( BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION )
 
     template<class Ap>
-    typename boost::detail::sp_enable_if_auto_ptr< Ap, shared_ptr & >::type operator=( Ap r )
+    typename boost::detail::sp_enable_if_auto_ptr< Ap, boost::shared_ptr & >::type operator=( Ap r )
     {
         this_type( r ).swap( *this );
         return *this;
@@ -344,7 +344,7 @@ public:
 
 #if defined( BOOST_HAS_RVALUE_REFS )
 
-    shared_ptr( shared_ptr && r ): px( r.px ), pn() // never throws
+    boost::shared_ptr( boost::shared_ptr && r ): px( r.px ), pn() // never throws
     {
         pn.swap( r.pn );
         r.px = 0;
@@ -353,11 +353,11 @@ public:
     template<class Y>
 #if !defined( BOOST_SP_NO_SP_CONVERTIBLE )
 
-    shared_ptr( shared_ptr<Y> && r, typename boost::detail::sp_enable_if_convertible<Y,T>::type = boost::detail::sp_empty() )
+    boost::shared_ptr( boost::shared_ptr<Y> && r, typename boost::detail::sp_enable_if_convertible<Y,T>::type = boost::detail::sp_empty() )
 
 #else
 
-    shared_ptr( shared_ptr<Y> && r )
+    boost::shared_ptr( boost::shared_ptr<Y> && r )
 
 #endif
     : px( r.px ), pn() // never throws
@@ -366,16 +366,16 @@ public:
         r.px = 0;
     }
 
-    shared_ptr & operator=( shared_ptr && r ) // never throws
+    boost::shared_ptr & operator=( boost::shared_ptr && r ) // never throws
     {
-        this_type( static_cast< shared_ptr && >( r ) ).swap( *this );
+        this_type( static_cast< boost::shared_ptr && >( r ) ).swap( *this );
         return *this;
     }
 
     template<class Y>
-    shared_ptr & operator=( shared_ptr<Y> && r ) // never throws
+    boost::shared_ptr & operator=( boost::shared_ptr<Y> && r ) // never throws
     {
-        this_type( static_cast< shared_ptr<Y> && >( r ) ).swap( *this );
+        this_type( static_cast< boost::shared_ptr<Y> && >( r ) ).swap( *this );
         return *this;
     }
 
@@ -402,7 +402,7 @@ public:
         this_type( p, d, a ).swap( *this );
     }
 
-    template<class Y> void reset( shared_ptr<Y> const & r, T * p )
+    template<class Y> void reset( boost::shared_ptr<Y> const & r, T * p )
     {
         this_type( r, p ).swap( *this );
     }
@@ -437,13 +437,13 @@ public:
         return pn.use_count();
     }
 
-    void swap(shared_ptr<T> & other) // never throws
+    void swap(boost::shared_ptr<T> & other) // never throws
     {
         std::swap(px, other.px);
         pn.swap(other.pn);
     }
 
-    template<class Y> bool _internal_less(shared_ptr<Y> const & rhs) const
+    template<class Y> bool _internal_less(boost::shared_ptr<Y> const & rhs) const
     {
         return pn < rhs.pn;
     }
@@ -453,7 +453,7 @@ public:
         return pn.get_deleter( ti );
     }
 
-    bool _internal_equiv( shared_ptr const & r ) const
+    bool _internal_equiv( boost::shared_ptr const & r ) const
     {
         return px == r.px && pn == r.pn;
     }
@@ -465,7 +465,7 @@ public:
 
 private:
 
-    template<class Y> friend class shared_ptr;
+    template<class Y> friend class boost::shared_ptr;
     template<class Y> friend class weak_ptr;
 
 
@@ -474,14 +474,14 @@ private:
     T * px;                     // contained pointer
     boost::detail::shared_count pn;    // reference counter
 
-};  // shared_ptr
+};  // boost::shared_ptr
 
-template<class T, class U> inline bool operator==(shared_ptr<T> const & a, shared_ptr<U> const & b)
+template<class T, class U> inline bool operator==(boost::shared_ptr<T> const & a, boost::shared_ptr<U> const & b)
 {
     return a.get() == b.get();
 }
 
-template<class T, class U> inline bool operator!=(shared_ptr<T> const & a, shared_ptr<U> const & b)
+template<class T, class U> inline bool operator!=(boost::shared_ptr<T> const & a, boost::shared_ptr<U> const & b)
 {
     return a.get() != b.get();
 }
@@ -490,64 +490,64 @@ template<class T, class U> inline bool operator!=(shared_ptr<T> const & a, share
 
 // Resolve the ambiguity between our op!= and the one in rel_ops
 
-template<class T> inline bool operator!=(shared_ptr<T> const & a, shared_ptr<T> const & b)
+template<class T> inline bool operator!=(boost::shared_ptr<T> const & a, boost::shared_ptr<T> const & b)
 {
     return a.get() != b.get();
 }
 
 #endif
 
-template<class T, class U> inline bool operator<(shared_ptr<T> const & a, shared_ptr<U> const & b)
+template<class T, class U> inline bool operator<(boost::shared_ptr<T> const & a, boost::shared_ptr<U> const & b)
 {
     return a._internal_less(b);
 }
 
-template<class T> inline void swap(shared_ptr<T> & a, shared_ptr<T> & b)
+template<class T> inline void swap(boost::shared_ptr<T> & a, boost::shared_ptr<T> & b)
 {
     a.swap(b);
 }
 
-template<class T, class U> shared_ptr<T> static_pointer_cast(shared_ptr<U> const & r)
+template<class T, class U> boost::shared_ptr<T> static_pointer_cast(boost::shared_ptr<U> const & r)
 {
-    return shared_ptr<T>(r, boost::detail::static_cast_tag());
+    return boost::shared_ptr<T>(r, boost::detail::static_cast_tag());
 }
 
-template<class T, class U> shared_ptr<T> const_pointer_cast(shared_ptr<U> const & r)
+template<class T, class U> boost::shared_ptr<T> const_pointer_cast(boost::shared_ptr<U> const & r)
 {
-    return shared_ptr<T>(r, boost::detail::const_cast_tag());
+    return boost::shared_ptr<T>(r, boost::detail::const_cast_tag());
 }
 
-template<class T, class U> shared_ptr<T> dynamic_pointer_cast(shared_ptr<U> const & r)
+template<class T, class U> boost::shared_ptr<T> dynamic_pointer_cast(boost::shared_ptr<U> const & r)
 {
-    return shared_ptr<T>(r, boost::detail::dynamic_cast_tag());
+    return boost::shared_ptr<T>(r, boost::detail::dynamic_cast_tag());
 }
 
 // shared_*_cast names are deprecated. Use *_pointer_cast instead.
 
-template<class T, class U> shared_ptr<T> shared_static_cast(shared_ptr<U> const & r)
+template<class T, class U> boost::shared_ptr<T> shared_static_cast(boost::shared_ptr<U> const & r)
 {
-    return shared_ptr<T>(r, boost::detail::static_cast_tag());
+    return boost::shared_ptr<T>(r, boost::detail::static_cast_tag());
 }
 
-template<class T, class U> shared_ptr<T> shared_dynamic_cast(shared_ptr<U> const & r)
+template<class T, class U> boost::shared_ptr<T> shared_dynamic_cast(boost::shared_ptr<U> const & r)
 {
-    return shared_ptr<T>(r, boost::detail::dynamic_cast_tag());
+    return boost::shared_ptr<T>(r, boost::detail::dynamic_cast_tag());
 }
 
-template<class T, class U> shared_ptr<T> shared_polymorphic_cast(shared_ptr<U> const & r)
+template<class T, class U> boost::shared_ptr<T> shared_polymorphic_cast(boost::shared_ptr<U> const & r)
 {
-    return shared_ptr<T>(r, boost::detail::polymorphic_cast_tag());
+    return boost::shared_ptr<T>(r, boost::detail::polymorphic_cast_tag());
 }
 
-template<class T, class U> shared_ptr<T> shared_polymorphic_downcast(shared_ptr<U> const & r)
+template<class T, class U> boost::shared_ptr<T> shared_polymorphic_downcast(boost::shared_ptr<U> const & r)
 {
     BOOST_ASSERT(dynamic_cast<T *>(r.get()) == r.get());
     return shared_static_cast<T>(r);
 }
 
-// get_pointer() enables boost::mem_fn to recognize shared_ptr
+// get_pointer() enables boost::mem_fn to recognize boost::shared_ptr
 
-template<class T> inline T * get_pointer(shared_ptr<T> const & p)
+template<class T> inline T * get_pointer(boost::shared_ptr<T> const & p)
 {
     return p.get();
 }
@@ -558,7 +558,7 @@ template<class T> inline T * get_pointer(shared_ptr<T> const & p)
 
 #if defined(BOOST_NO_TEMPLATED_IOSTREAMS) || ( defined(__GNUC__) &&  (__GNUC__ < 3) )
 
-template<class Y> std::ostream & operator<< (std::ostream & os, shared_ptr<Y> const & p)
+template<class Y> std::ostream & operator<< (std::ostream & os, boost::shared_ptr<Y> const & p)
 {
     os << p.get();
     return os;
@@ -572,9 +572,9 @@ template<class Y> std::ostream & operator<< (std::ostream & os, shared_ptr<Y> co
 # if defined(BOOST_MSVC) && BOOST_WORKAROUND(BOOST_MSVC, < 1300 && __SGI_STL_PORT)
 // MSVC6 has problems finding std::basic_ostream through the using declaration in namespace _STL
 using std::basic_ostream;
-template<class E, class T, class Y> basic_ostream<E, T> & operator<< (basic_ostream<E, T> & os, shared_ptr<Y> const & p)
+template<class E, class T, class Y> basic_ostream<E, T> & operator<< (basic_ostream<E, T> & os, boost::shared_ptr<Y> const & p)
 # else
-template<class E, class T, class Y> std::basic_ostream<E, T> & operator<< (std::basic_ostream<E, T> & os, shared_ptr<Y> const & p)
+template<class E, class T, class Y> std::basic_ostream<E, T> & operator<< (std::basic_ostream<E, T> & os, boost::shared_ptr<Y> const & p)
 # endif
 {
     os << p.get();
@@ -596,7 +596,7 @@ template<class E, class T, class Y> std::basic_ostream<E, T> & operator<< (std::
 // g++ 2.9x doesn't allow static_cast<X const *>(void *)
 // apparently EDG 2.38 and HP aCC A.03.35 also don't accept it
 
-template<class D, class T> D * get_deleter(shared_ptr<T> const & p)
+template<class D, class T> D * get_deleter(boost::shared_ptr<T> const & p)
 {
     void const * q = p._internal_get_deleter(BOOST_SP_TYPEID(D));
     return const_cast<D *>(static_cast<D const *>(q));
@@ -604,7 +604,7 @@ template<class D, class T> D * get_deleter(shared_ptr<T> const & p)
 
 #else
 
-template<class D, class T> D * get_deleter(shared_ptr<T> const & p)
+template<class D, class T> D * get_deleter(boost::shared_ptr<T> const & p)
 {
     return static_cast<D *>(p._internal_get_deleter(BOOST_SP_TYPEID(D)));
 }
@@ -615,34 +615,34 @@ template<class D, class T> D * get_deleter(shared_ptr<T> const & p)
 
 #if !defined(BOOST_SP_NO_ATOMIC_ACCESS)
 
-template<class T> inline bool atomic_is_lock_free( shared_ptr<T> const * /*p*/ )
+template<class T> inline bool atomic_is_lock_free( boost::shared_ptr<T> const * /*p*/ )
 {
     return false;
 }
 
-template<class T> shared_ptr<T> atomic_load( shared_ptr<T> const * p )
+template<class T> boost::shared_ptr<T> atomic_load( boost::shared_ptr<T> const * p )
 {
     boost::detail::spinlock_pool<2>::scoped_lock lock( p );
     return *p;
 }
 
-template<class T> inline shared_ptr<T> atomic_load_explicit( shared_ptr<T> const * p, memory_order /*mo*/ )
+template<class T> inline boost::shared_ptr<T> atomic_load_explicit( boost::shared_ptr<T> const * p, memory_order /*mo*/ )
 {
     return atomic_load( p );
 }
 
-template<class T> void atomic_store( shared_ptr<T> * p, shared_ptr<T> r )
+template<class T> void atomic_store( boost::shared_ptr<T> * p, boost::shared_ptr<T> r )
 {
     boost::detail::spinlock_pool<2>::scoped_lock lock( p );
     p->swap( r );
 }
 
-template<class T> inline void atomic_store_explicit( shared_ptr<T> * p, shared_ptr<T> r, memory_order /*mo*/ )
+template<class T> inline void atomic_store_explicit( boost::shared_ptr<T> * p, boost::shared_ptr<T> r, memory_order /*mo*/ )
 {
     atomic_store( p, r ); // std::move( r )
 }
 
-template<class T> shared_ptr<T> atomic_exchange( shared_ptr<T> * p, shared_ptr<T> r )
+template<class T> boost::shared_ptr<T> atomic_exchange( boost::shared_ptr<T> * p, boost::shared_ptr<T> r )
 {
     boost::detail::spinlock & sp = boost::detail::spinlock_pool<2>::spinlock_for( p );
 
@@ -653,12 +653,12 @@ template<class T> shared_ptr<T> atomic_exchange( shared_ptr<T> * p, shared_ptr<T
     return r; // return std::move( r )
 }
 
-template<class T> shared_ptr<T> atomic_exchange_explicit( shared_ptr<T> * p, shared_ptr<T> r, memory_order /*mo*/ )
+template<class T> boost::shared_ptr<T> atomic_exchange_explicit( boost::shared_ptr<T> * p, boost::shared_ptr<T> r, memory_order /*mo*/ )
 {
     return atomic_exchange( p, r ); // std::move( r )
 }
 
-template<class T> bool atomic_compare_exchange( shared_ptr<T> * p, shared_ptr<T> * v, shared_ptr<T> w )
+template<class T> bool atomic_compare_exchange( boost::shared_ptr<T> * p, boost::shared_ptr<T> * v, boost::shared_ptr<T> w )
 {
     boost::detail::spinlock & sp = boost::detail::spinlock_pool<2>::spinlock_for( p );
 
@@ -674,7 +674,7 @@ template<class T> bool atomic_compare_exchange( shared_ptr<T> * p, shared_ptr<T>
     }
     else
     {
-        shared_ptr<T> tmp( *p );
+        boost::shared_ptr<T> tmp( *p );
 
         sp.unlock();
 
@@ -683,7 +683,7 @@ template<class T> bool atomic_compare_exchange( shared_ptr<T> * p, shared_ptr<T>
     }
 }
 
-template<class T> inline bool atomic_compare_exchange_explicit( shared_ptr<T> * p, shared_ptr<T> * v, shared_ptr<T> w, memory_order /*success*/, memory_order /*failure*/ )
+template<class T> inline bool atomic_compare_exchange_explicit( boost::shared_ptr<T> * p, boost::shared_ptr<T> * v, boost::shared_ptr<T> w, memory_order /*success*/, memory_order /*failure*/ )
 {
     return atomic_compare_exchange( p, v, w ); // std::move( w )
 }
diff --git a/libraries/boost/boost/smart_ptr/weak_ptr.hpp b/libraries/boost/boost/smart_ptr/weak_ptr.hpp
index d314b0d..4b62c28 100644
--- a/libraries/boost/boost/smart_ptr/weak_ptr.hpp
+++ b/libraries/boost/boost/smart_ptr/weak_ptr.hpp
@@ -110,11 +110,11 @@ public:
     template<class Y>
 #if !defined( BOOST_SP_NO_SP_CONVERTIBLE )
 
-    weak_ptr( shared_ptr<Y> const & r, typename boost::detail::sp_enable_if_convertible<Y,T>::type = boost::detail::sp_empty() )
+    weak_ptr( boost::shared_ptr<Y> const & r, typename boost::detail::sp_enable_if_convertible<Y,T>::type = boost::detail::sp_empty() )
 
 #else
 
-    weak_ptr( shared_ptr<Y> const & r )
+    weak_ptr( boost::shared_ptr<Y> const & r )
 
 #endif
     : px( r.px ), pn( r.pn ) // never throws
@@ -143,7 +143,7 @@ public:
 #endif
 
     template<class Y>
-    weak_ptr & operator=(shared_ptr<Y> const & r) // never throws
+    weak_ptr & operator=(boost::shared_ptr<Y> const & r) // never throws
     {
         px = r.px;
         pn = r.pn;
@@ -152,9 +152,9 @@ public:
 
 #endif
 
-    shared_ptr<T> lock() const // never throws
+    boost::shared_ptr<T> lock() const // never throws
     {
-        return shared_ptr<element_type>( *this, boost::detail::sp_nothrow_tag() );
+        return boost::shared_ptr<element_type>( *this, boost::detail::sp_nothrow_tag() );
     }
 
     long use_count() const // never throws
@@ -202,7 +202,7 @@ public:
 private:
 
     template<class Y> friend class weak_ptr;
-    template<class Y> friend class shared_ptr;
+    template<class Y> friend class boost::shared_ptr;
 
 #endif
 
diff --git a/libraries/boost/boost/tr1/memory.hpp b/libraries/boost/boost/tr1/memory.hpp
index 81d9d45..9ca3b03 100644
--- a/libraries/boost/boost/tr1/memory.hpp
+++ b/libraries/boost/boost/tr1/memory.hpp
@@ -22,13 +22,13 @@ namespace boost{
 
 class bad_weak_ptr;
 template<class T> class weak_ptr;
-template<class T> class shared_ptr;
+template<class T> class boost::shared_ptr;
 template<class T> void swap(weak_ptr<T> & a, weak_ptr<T> & b);
-template<class T> void swap(shared_ptr<T> & a, shared_ptr<T> & b);
-template<class T, class U> shared_ptr<T> static_pointer_cast(shared_ptr<U> const & r);
-template<class T, class U> shared_ptr<T> dynamic_pointer_cast(shared_ptr<U> const & r);
-template<class T, class U> shared_ptr<T> const_pointer_cast(shared_ptr<U> const & r);
-template<class D, class T> D * get_deleter(shared_ptr<T> const & p);
+template<class T> void swap(boost::shared_ptr<T> & a, boost::shared_ptr<T> & b);
+template<class T, class U> boost::shared_ptr<T> static_pointer_cast(boost::shared_ptr<U> const & r);
+template<class T, class U> boost::shared_ptr<T> dynamic_pointer_cast(boost::shared_ptr<U> const & r);
+template<class T, class U> boost::shared_ptr<T> const_pointer_cast(boost::shared_ptr<U> const & r);
+template<class D, class T> D * get_deleter(boost::shared_ptr<T> const & p);
 template<class T> class enable_shared_from_this;
 
 namespace detail{
diff --git a/libraries/boost/boost/uuid/random_generator.hpp b/libraries/boost/boost/uuid/random_generator.hpp
index 4d11f6b..6b86ebe 100644
--- a/libraries/boost/boost/uuid/random_generator.hpp
+++ b/libraries/boost/boost/uuid/random_generator.hpp
@@ -107,7 +107,7 @@ public:
     }
 
 private:
-    shared_ptr<UniformRandomNumberGenerator> pURNG;
+    boost::shared_ptr<UniformRandomNumberGenerator> pURNG;
     generator_type generator;
 };
 
diff --git a/source/backend/bounding/boundingtask.cpp b/source/backend/bounding/boundingtask.cpp
index 40634a1..410b025 100644
--- a/source/backend/bounding/boundingtask.cpp
+++ b/source/backend/bounding/boundingtask.cpp
@@ -128,7 +128,7 @@ class BSPProgress : public BSPTree::Progress
 		BSPProgress();
 };
 
-BoundingTask::BoundingTask(shared_ptr<SceneData> sd, unsigned int bt) :
+BoundingTask::BoundingTask(boost::shared_ptr<SceneData> sd, unsigned int bt) :
 	Task(new SceneThreadData(sd), boost::bind(&BoundingTask::SendFatalError, this, _1)),
 	sceneData(sd),
 	boundingThreshold(bt)
diff --git a/source/backend/bounding/boundingtask.h b/source/backend/bounding/boundingtask.h
index 989f3eb..fbfe011 100644
--- a/source/backend/bounding/boundingtask.h
+++ b/source/backend/bounding/boundingtask.h
@@ -51,7 +51,7 @@ namespace pov
 class BoundingTask : public Task
 {
 	public:
-		BoundingTask(shared_ptr<SceneData> sd, unsigned int bt);
+		BoundingTask(boost::shared_ptr<SceneData> sd, unsigned int bt);
 		virtual ~BoundingTask();
 
 		virtual void Run();
@@ -62,7 +62,7 @@ class BoundingTask : public Task
 
 		inline SceneThreadData *GetSceneDataPtr() { return (SceneThreadData *)(GetDataPtr()); }
 	private:
-		shared_ptr<SceneData> sceneData;
+		boost::shared_ptr<SceneData> sceneData;
 		unsigned int boundingThreshold;
 
 		void SendFatalError(pov_base::Exception& e);
diff --git a/source/backend/control/renderbackend.cpp b/source/backend/control/renderbackend.cpp
index 8ac5f82..96644cf 100644
--- a/source/backend/control/renderbackend.cpp
+++ b/source/backend/control/renderbackend.cpp
@@ -298,7 +298,7 @@ void RenderBackend::CreateScene(POVMS_Message& msg, POVMS_Message& result, int)
 		if(err != kNoErr)
 			throw POV_EXCEPTION_CODE (err);
 
-		shared_ptr<Scene> scene(new Scene(backendAddress, msg.GetSourceAddress(), scenecounter + 1));
+		boost::shared_ptr<Scene> scene(new Scene(backendAddress, msg.GetSourceAddress(), scenecounter + 1));
 
 		scenecounter++;
 
@@ -340,7 +340,7 @@ void RenderBackend::CloseScene(POVMS_Message& msg, POVMS_Message& result, int)
 	{
 		SceneId sid = msg.GetInt(kPOVAttrib_SceneId);
 
-		map<SceneId, shared_ptr<Scene> >::iterator i(scenes.find(sid));
+		map<SceneId, boost::shared_ptr<Scene> >::iterator i(scenes.find(sid));
 
 		if(i == scenes.end())
 			throw POV_EXCEPTION_CODE(kInvalidIdentifierErr);
@@ -376,12 +376,12 @@ void RenderBackend::CreateView(POVMS_Message& msg, POVMS_Message& result, int)
 	{
 		SceneId sid = msg.GetInt(kPOVAttrib_SceneId);
 
-		map<SceneId, shared_ptr<Scene> >::iterator i(scenes.find(sid));
+		map<SceneId, boost::shared_ptr<Scene> >::iterator i(scenes.find(sid));
 
 		if(i == scenes.end())
 			throw POV_EXCEPTION_CODE(kInvalidIdentifierErr);
 
-		shared_ptr<View> view(i->second->NewView(msg.TryGetInt(kPOVAttrib_Width, 160), msg.TryGetInt(kPOVAttrib_Height, 120), viewcounter + 1));
+		boost::shared_ptr<View> view(i->second->NewView(msg.TryGetInt(kPOVAttrib_Width, 160), msg.TryGetInt(kPOVAttrib_Height, 120), viewcounter + 1));
 
 		viewcounter++;
 
@@ -416,7 +416,7 @@ void RenderBackend::CloseView(POVMS_Message& msg, POVMS_Message& result, int)
 	{
 		ViewId vid = msg.GetInt(kPOVAttrib_ViewId);
 
-		map<ViewId, shared_ptr<View> >::iterator i(views.find(vid));
+		map<ViewId, boost::shared_ptr<View> >::iterator i(views.find(vid));
 
 		if(i == views.end())
 			throw POV_EXCEPTION_CODE(kInvalidIdentifierErr);
@@ -452,7 +452,7 @@ void RenderBackend::StartParser(POVMS_Message& msg, POVMS_Message&, int)
 			if(validateFrontendAddress(msg.GetSourceAddress()) == false)
 				throw POV_EXCEPTION_CODE(kAuthorisationErr);
 
-			map<SceneId, shared_ptr<Scene> >::iterator i(scenes.find(sid));
+			map<SceneId, boost::shared_ptr<Scene> >::iterator i(scenes.find(sid));
 
 			if(i == scenes.end())
 				throw POV_EXCEPTION_CODE(kInvalidIdentifierErr);
@@ -487,7 +487,7 @@ void RenderBackend::StopParser(POVMS_Message& msg, POVMS_Message& result, int)
 	{
 		SceneId sid = msg.GetInt(kPOVAttrib_SceneId);
 
-		map<SceneId, shared_ptr<Scene> >::iterator i(scenes.find(sid));
+		map<SceneId, boost::shared_ptr<Scene> >::iterator i(scenes.find(sid));
 
 		if(i == scenes.end())
 			throw POV_EXCEPTION_CODE(kInvalidIdentifierErr);
@@ -522,7 +522,7 @@ void RenderBackend::PauseParser(POVMS_Message& msg, POVMS_Message& result, int)
 	{
 		SceneId sid = msg.GetInt(kPOVAttrib_SceneId);
 
-		map<SceneId, shared_ptr<Scene> >::iterator i(scenes.find(sid));
+		map<SceneId, boost::shared_ptr<Scene> >::iterator i(scenes.find(sid));
 
 		if(i == scenes.end())
 			throw POV_EXCEPTION_CODE(kInvalidIdentifierErr);
@@ -557,7 +557,7 @@ void RenderBackend::ResumeParser(POVMS_Message& msg, POVMS_Message& result, int)
 	{
 		SceneId sid = msg.GetInt(kPOVAttrib_SceneId);
 
-		map<SceneId, shared_ptr<Scene> >::iterator i(scenes.find(sid));
+		map<SceneId, boost::shared_ptr<Scene> >::iterator i(scenes.find(sid));
 
 		if(i == scenes.end())
 			throw POV_EXCEPTION_CODE(kInvalidIdentifierErr);
@@ -594,7 +594,7 @@ void RenderBackend::StartRender(POVMS_Message& msg, POVMS_Message&, int)
 			if(validateFrontendAddress(msg.GetSourceAddress()) == false)
 				throw POV_EXCEPTION_CODE(kAuthorisationErr);
 
-			map<ViewId, shared_ptr<View> >::iterator i(views.find(vid));
+			map<ViewId, boost::shared_ptr<View> >::iterator i(views.find(vid));
 
 			if(i == views.end())
 				throw POV_EXCEPTION_CODE(kInvalidIdentifierErr);
@@ -632,7 +632,7 @@ void RenderBackend::StopRender(POVMS_Message& msg, POVMS_Message& result, int)
 	{
 		ViewId vid = msg.GetInt(kPOVAttrib_ViewId);
 
-		map<ViewId, shared_ptr<View> >::iterator i(views.find(vid));
+		map<ViewId, boost::shared_ptr<View> >::iterator i(views.find(vid));
 
 		if(i == views.end())
 			throw POV_EXCEPTION_CODE(kInvalidIdentifierErr);
@@ -667,7 +667,7 @@ void RenderBackend::PauseRender(POVMS_Message& msg, POVMS_Message& result, int)
 	{
 		ViewId vid = msg.GetInt(kPOVAttrib_ViewId);
 
-		map<ViewId, shared_ptr<View> >::iterator i(views.find(vid));
+		map<ViewId, boost::shared_ptr<View> >::iterator i(views.find(vid));
 
 		if(i == views.end())
 			throw POV_EXCEPTION_CODE(kInvalidIdentifierErr);
@@ -702,7 +702,7 @@ void RenderBackend::ResumeRender(POVMS_Message& msg, POVMS_Message& result, int)
 	{
 		ViewId vid = msg.GetInt(kPOVAttrib_ViewId);
 
-		map<ViewId, shared_ptr<View> >::iterator i(views.find(vid));
+		map<ViewId, boost::shared_ptr<View> >::iterator i(views.find(vid));
 
 		if(i == views.end())
 			throw POV_EXCEPTION_CODE(kInvalidIdentifierErr);
diff --git a/source/backend/control/renderbackend.h b/source/backend/control/renderbackend.h
index 8186ff1..51aa50b 100644
--- a/source/backend/control/renderbackend.h
+++ b/source/backend/control/renderbackend.h
@@ -109,8 +109,8 @@ class RenderBackend : public POVMS_MessageReceiver
 		SceneId scenecounter;
 		ViewId viewcounter;
 
-		map<SceneId, shared_ptr<Scene> > scenes;
-		map<ViewId, shared_ptr<View> > views;
+		map<SceneId, boost::shared_ptr<Scene> > scenes;
+		map<ViewId, boost::shared_ptr<View> > views;
 		map<SceneId, set<ViewId> > scene2views;
 		map<ViewId, SceneId> view2scene;
 
diff --git a/source/backend/frame.h b/source/backend/frame.h
index 3e8ddea..1e7cae0 100644
--- a/source/backend/frame.h
+++ b/source/backend/frame.h
@@ -979,7 +979,7 @@ class Interior
 		SNGL Fade_Distance, Fade_Power;
 		RGBColour Fade_Colour;
 		vector<Media> media;
-		shared_ptr<SubsurfaceInterior> subsurface;
+		boost::shared_ptr<SubsurfaceInterior> subsurface;
 
 		Interior();
 		Interior(const Interior&);
diff --git a/source/backend/interior/interior.cpp b/source/backend/interior/interior.cpp
index 38b67bb..42040c6 100644
--- a/source/backend/interior/interior.cpp
+++ b/source/backend/interior/interior.cpp
@@ -63,7 +63,7 @@ Interior::Interior()
 
 	hollow = false;
 
-	subsurface = shared_ptr<SubsurfaceInterior>();
+	subsurface = boost::shared_ptr<SubsurfaceInterior>();
 }
 
 Interior::Interior(const Interior& source)
@@ -78,7 +78,7 @@ Interior::Interior(const Interior& source)
 	media = source.media;
 	hollow = source.hollow;
 	IOR = source.IOR;
-	subsurface = shared_ptr<SubsurfaceInterior>(source.subsurface);
+	subsurface = boost::shared_ptr<SubsurfaceInterior>(source.subsurface);
 	Caustics = source.Caustics;
 }
 
diff --git a/source/backend/lighting/photonestimationtask.cpp b/source/backend/lighting/photonestimationtask.cpp
index 863e022..e16b4fc 100644
--- a/source/backend/lighting/photonestimationtask.cpp
+++ b/source/backend/lighting/photonestimationtask.cpp
@@ -131,7 +131,7 @@ void PhotonEstimationTask::Finish()
 void PhotonEstimationTask::SearchThroughObjectsEstimatePhotons(vector<ObjectPtr>& Objects, LightSource *Light)
 {
 	ViewThreadData *renderDataPtr = GetViewDataPtr();
-	shared_ptr<SceneData> sceneData = GetSceneData();
+	boost::shared_ptr<SceneData> sceneData = GetSceneData();
 
 	/* check this object and all siblings */
 	for(vector<ObjectPtr>::iterator Sib = Objects.begin(); Sib != Objects.end(); Sib++)
diff --git a/source/backend/lighting/photons.cpp b/source/backend/lighting/photons.cpp
index 75a92a7..89372fd 100644
--- a/source/backend/lighting/photons.cpp
+++ b/source/backend/lighting/photons.cpp
@@ -105,7 +105,7 @@ const int PHOTON_BLOCK_MASK = (PHOTON_BLOCK_SIZE-1);
 const int INITIAL_BASE_ARRAY_SIZE = 100;
 
 
-PhotonTrace::PhotonTrace(shared_ptr<SceneData> sd, TraceThreadData *td, unsigned int mtl, DBL adcb, unsigned int qf, Trace::CooperateFunctor& cf) :
+PhotonTrace::PhotonTrace(boost::shared_ptr<SceneData> sd, TraceThreadData *td, unsigned int mtl, DBL adcb, unsigned int qf, Trace::CooperateFunctor& cf) :
 	Trace(sd, td, qf, cf, mediaPhotons, noRadiosity),
 	mediaPhotons(sd, td, this, new PhotonGatherer(&sd->mediaPhotonMap, sd->photonSettings))
 {
@@ -960,7 +960,7 @@ void PhotonTrace::addSurfacePhoton(const VECTOR Point, const VECTOR Origin, cons
 
 }
 
-PhotonMediaFunction::PhotonMediaFunction(shared_ptr<SceneData> sd, TraceThreadData *td, Trace *t, PhotonGatherer *pg) :
+PhotonMediaFunction::PhotonMediaFunction(boost::shared_ptr<SceneData> sd, TraceThreadData *td, Trace *t, PhotonGatherer *pg) :
 	MediaFunction(td, t, pg),
 	sceneData(sd)
 {
@@ -2748,7 +2748,7 @@ int LightTargetCombo::computeMergedFlags()
 }
 
 
-void LightTargetCombo::computeAnglesAndDeltas(shared_ptr<SceneData> sceneData)
+void LightTargetCombo::computeAnglesAndDeltas(boost::shared_ptr<SceneData> sceneData)
 {
 	shootingDirection.compute();
 
diff --git a/source/backend/lighting/photons.h b/source/backend/lighting/photons.h
index d10d4f0..e39c619 100644
--- a/source/backend/lighting/photons.h
+++ b/source/backend/lighting/photons.h
@@ -295,14 +295,14 @@ class PhotonGatherer
 class PhotonMediaFunction : public MediaFunction
 {
 	public:
-		PhotonMediaFunction(shared_ptr<SceneData> sd, TraceThreadData *td, Trace *t, PhotonGatherer *pg);
+		PhotonMediaFunction(boost::shared_ptr<SceneData> sd, TraceThreadData *td, Trace *t, PhotonGatherer *pg);
 
 		void ComputeMediaAndDepositPhotons(MediaVector& medias, const Ray& ray, const Intersection& isect, Colour& colour, Trace::TraceTicket& ticket);
 	protected:
 		void DepositMediaPhotons(Colour& colour, MediaVector& medias, LightSourceEntryVector& lights, MediaIntervalVector& mediaintervals,
 		                         const Ray& ray, int minsamples, bool ignore_photons, bool use_scattering, bool all_constant_and_light_ray, Trace::TraceTicket& ticket);
 	private:
-		shared_ptr<SceneData> sceneData;
+		boost::shared_ptr<SceneData> sceneData;
 
 		void addMediaPhoton(const VECTOR Point, const VECTOR Origin, const RGBColour& LightCol, DBL depthDiff);
 };
@@ -310,7 +310,7 @@ class PhotonMediaFunction : public MediaFunction
 class PhotonTrace : public Trace
 {
 	public:
-		PhotonTrace(shared_ptr<SceneData> sd, TraceThreadData *td, unsigned int mtl, DBL adcb, unsigned int qf, Trace::CooperateFunctor& cf);
+		PhotonTrace(boost::shared_ptr<SceneData> sd, TraceThreadData *td, unsigned int mtl, DBL adcb, unsigned int qf, Trace::CooperateFunctor& cf);
 		~PhotonTrace();
 
 		virtual DBL TraceRay(const Ray& ray, Colour& colour, COLC weight, Trace::TraceTicket& ticket, bool continuedRay, DBL maxDepth = 0.0);
@@ -363,7 +363,7 @@ class LightTargetCombo
 		ShootingDirection shootingDirection;
 
 		int computeMergedFlags();
-		void computeAnglesAndDeltas(shared_ptr<SceneData> sceneData);
+		void computeAnglesAndDeltas(boost::shared_ptr<SceneData> sceneData);
 };
 
 
diff --git a/source/backend/lighting/photonshootingstrategy.cpp b/source/backend/lighting/photonshootingstrategy.cpp
index f06d426..7d15e8c 100644
--- a/source/backend/lighting/photonshootingstrategy.cpp
+++ b/source/backend/lighting/photonshootingstrategy.cpp
@@ -77,7 +77,7 @@ PhotonShootingUnit* PhotonShootingStrategy::getNextUnit()
 	return unit;
 }
 
-void PhotonShootingStrategy::createUnitsForCombo(ObjectPtr obj, LightSource* light, shared_ptr<SceneData> sceneData)
+void PhotonShootingStrategy::createUnitsForCombo(ObjectPtr obj, LightSource* light, boost::shared_ptr<SceneData> sceneData)
 {
 	PhotonShootingUnit* unit = new PhotonShootingUnit(light, obj);
 	unit->lightAndObject.computeAnglesAndDeltas(sceneData);
diff --git a/source/backend/lighting/photonshootingstrategy.h b/source/backend/lighting/photonshootingstrategy.h
index 2c4b68a..b385114 100644
--- a/source/backend/lighting/photonshootingstrategy.h
+++ b/source/backend/lighting/photonshootingstrategy.h
@@ -54,7 +54,7 @@ class PhotonShootingStrategy
 
 		vector<PhotonShootingUnit*> units;
 
-		void createUnitsForCombo(ObjectPtr obj, LightSource* light, shared_ptr<SceneData> sceneData);
+		void createUnitsForCombo(ObjectPtr obj, LightSource* light, boost::shared_ptr<SceneData> sceneData);
 		void start();
 		PhotonShootingUnit* getNextUnit();
 
diff --git a/source/backend/lighting/photonstrategytask.cpp b/source/backend/lighting/photonstrategytask.cpp
index cd34a08..bd5ccdc 100644
--- a/source/backend/lighting/photonstrategytask.cpp
+++ b/source/backend/lighting/photonstrategytask.cpp
@@ -168,7 +168,7 @@ void PhotonStrategyTask::Finish()
 
 void PhotonStrategyTask::SearchThroughObjectsCreateUnits(vector<ObjectPtr>& Objects, LightSource *Light)
 {
-	shared_ptr<SceneData> sceneData = GetSceneData();
+	boost::shared_ptr<SceneData> sceneData = GetSceneData();
 
 	/* check this object and all siblings */
 	for(vector<ObjectPtr>::iterator Sib = Objects.begin(); Sib != Objects.end(); Sib++)
diff --git a/source/backend/lighting/radiosity.cpp b/source/backend/lighting/radiosity.cpp
index 187bb92..d31a0d3 100644
--- a/source/backend/lighting/radiosity.cpp
+++ b/source/backend/lighting/radiosity.cpp
@@ -269,7 +269,7 @@ RadiosityRecursionSettings* SceneRadiositySettings::GetRecursionSettings(bool fi
 	return recSettings;
 }
 
-RadiosityFunction::RadiosityFunction(shared_ptr<SceneData> sd, TraceThreadData *td, const SceneRadiositySettings& rs,
+RadiosityFunction::RadiosityFunction(boost::shared_ptr<SceneData> sd, TraceThreadData *td, const SceneRadiositySettings& rs,
                                      RadiosityCache& rc, Trace::CooperateFunctor& cf, bool ft, const Vector3d& camera) :
 	threadData(td),
 	trace(sd, td, GetRadiosityQualityFlags(rs, QUALITY_9), cf, media, *this), // TODO FIXME - we can only use hard-coded QUALITY_9 because Radiosity happens to be disabled at lower settings!
diff --git a/source/backend/lighting/radiosity.h b/source/backend/lighting/radiosity.h
index 2ae2543..5cb27f7 100644
--- a/source/backend/lighting/radiosity.h
+++ b/source/backend/lighting/radiosity.h
@@ -255,7 +255,7 @@ class RadiosityFunction : public Trace::RadiosityFunctor
 		//      cf      - the cooperate functor (whatever that is - some thing that handles inter-thread communication?)
 		//      pts     - number of the current pretrace step (PRETRACE_FIRST to PRETRACE_MAX, or FINAL_TRACE for main render)
 		//      camera  - position of the camera
-		RadiosityFunction(shared_ptr<SceneData> sd, TraceThreadData *td,
+		RadiosityFunction(boost::shared_ptr<SceneData> sd, TraceThreadData *td,
 		                  const SceneRadiositySettings& rs, RadiosityCache& rc, Trace::CooperateFunctor& cf, bool ft, const Vector3d& camera);
 		virtual ~RadiosityFunction();
 
diff --git a/source/backend/parser/parse.cpp b/source/backend/parser/parse.cpp
index 7268519..e4986d3 100644
--- a/source/backend/parser/parse.cpp
+++ b/source/backend/parser/parse.cpp
@@ -122,7 +122,7 @@ const DBL INFINITE_VOLUME = BOUND_HUGE;
 *
 ******************************************************************************/
 
-Parser::Parser(shared_ptr<SceneData> sd, bool useclk, DBL clk) :
+Parser::Parser(boost::shared_ptr<SceneData> sd, bool useclk, DBL clk) :
 	Task(new SceneThreadData(sd), boost::bind(&Parser::SendFatalError, this, _1)),
 	sceneData(sd),
 	clockValue(clk),
@@ -9546,7 +9546,7 @@ void Parser::Post_Process (ObjectPtr Object, ObjectPtr Parent)
 		/* if(!Object->Texture->Finish->SubsurfaceTranslucency.isZero()) */
 		if (sceneData->useSubsurface)
 		{
-			Object->interior->subsurface = shared_ptr<SubsurfaceInterior>(new SubsurfaceInterior(Object->interior->IOR));
+			Object->interior->subsurface = boost::shared_ptr<SubsurfaceInterior>(new SubsurfaceInterior(Object->interior->IOR));
 		}
 	}
 
diff --git a/source/backend/parser/parse.h b/source/backend/parser/parse.h
index ea82e03..fe958ff 100644
--- a/source/backend/parser/parse.h
+++ b/source/backend/parser/parse.h
@@ -262,7 +262,7 @@ class Parser : public Task
 		};
 
 		// constructor
-		Parser(shared_ptr<SceneData> sd, bool useclock, DBL clock);
+		Parser(boost::shared_ptr<SceneData> sd, bool useclock, DBL clock);
 
 		void Run();
 		void Stopped();
@@ -411,7 +411,7 @@ class Parser : public Task
 		bool expr_ret(ExprNode *&current, int stage, int op);
 		bool expr_err(ExprNode *&current, int stage, int op);
 
-		shared_ptr<SceneData> sceneData; // TODO FIXME HACK - make private again once Locate_Filename is fixed [trf]
+		boost::shared_ptr<SceneData> sceneData; // TODO FIXME HACK - make private again once Locate_Filename is fixed [trf]
 	private:
 		FPUContext *fnVMContext;
 
diff --git a/source/backend/render/rendertask.cpp b/source/backend/render/rendertask.cpp
index e3d5eaa..567d746 100644
--- a/source/backend/render/rendertask.cpp
+++ b/source/backend/render/rendertask.cpp
@@ -61,7 +61,7 @@ RenderTask::~RenderTask()
 {
 }
 
-shared_ptr<SceneData>& RenderTask::GetSceneData()
+boost::shared_ptr<SceneData>& RenderTask::GetSceneData()
 {
 	return viewData->GetSceneData();
 }
diff --git a/source/backend/render/rendertask.h b/source/backend/render/rendertask.h
index c805f4f..f3afeed 100644
--- a/source/backend/render/rendertask.h
+++ b/source/backend/render/rendertask.h
@@ -52,7 +52,7 @@ class RenderTask : public Task
 		virtual void Run() = 0;
 		virtual void Stopped() = 0;
 
-		shared_ptr<SceneData>& GetSceneData();
+		boost::shared_ptr<SceneData>& GetSceneData();
 		ViewData *GetViewData();
 
 		inline ViewThreadData *GetViewDataPtr() { return (ViewThreadData *)(GetDataPtr()); }
diff --git a/source/backend/render/trace.cpp b/source/backend/render/trace.cpp
index e011908..114d17e 100644
--- a/source/backend/render/trace.cpp
+++ b/source/backend/render/trace.cpp
@@ -67,7 +67,7 @@ namespace pov
 
 #define MEDIA_AFTER_TEXTURE_INTERPOLATION 1
 
-Trace::Trace(shared_ptr<SceneData> sd, TraceThreadData *td, unsigned int qf,
+Trace::Trace(boost::shared_ptr<SceneData> sd, TraceThreadData *td, unsigned int qf,
              CooperateFunctor& cf, MediaFunctor& mf, RadiosityFunctor& rf) :
 	threadData(td),
 	sceneData(sd),
diff --git a/source/backend/render/trace.h b/source/backend/render/trace.h
index b3860e7..65f7c4a 100644
--- a/source/backend/render/trace.h
+++ b/source/backend/render/trace.h
@@ -200,7 +200,7 @@ class Trace
 				virtual bool CheckRadiosityTraceLevel(const Trace::TraceTicket& ticket) { return false; }
 		};
 
-		Trace(shared_ptr<SceneData> sd, TraceThreadData *td, unsigned int qf,
+		Trace(boost::shared_ptr<SceneData> sd, TraceThreadData *td, unsigned int qf,
 		      CooperateFunctor& cf, MediaFunctor& mf, RadiosityFunctor& af);
 		virtual ~Trace();
 
@@ -268,7 +268,7 @@ class Trace
 		int lightColorCacheIndex;
 
 		/// scene data
-		shared_ptr<SceneData> sceneData;
+		boost::shared_ptr<SceneData> sceneData;
 
 		/// maximum trace recursion level found
 		unsigned int maxFoundTraceLevel;
diff --git a/source/backend/render/tracepixel.h b/source/backend/render/tracepixel.h
index 212754b..d4164d0 100644
--- a/source/backend/render/tracepixel.h
+++ b/source/backend/render/tracepixel.h
@@ -250,7 +250,7 @@ class TracePixel : public Trace
 		/// camera
 		Camera camera;
 		/// scene data
-		shared_ptr<SceneData> sceneData;
+		boost::shared_ptr<SceneData> sceneData;
 		/// thread data
 		TraceThreadData *threadData;
 
diff --git a/source/backend/scene/scene.cpp b/source/backend/scene/scene.cpp
index 6da0aab..d4384a6 100644
--- a/source/backend/scene/scene.cpp
+++ b/source/backend/scene/scene.cpp
@@ -568,7 +568,7 @@ bool Scene::Failed()
 	return parserTasks.Failed();
 }
 
-shared_ptr<View> Scene::NewView(unsigned int width, unsigned int height, RenderBackend::ViewId vid)
+boost::shared_ptr<View> Scene::NewView(unsigned int width, unsigned int height, RenderBackend::ViewId vid)
 {
 	if(parserTasks.IsDone() == false)
 		throw POV_EXCEPTION_CODE(kNotNowErr);
@@ -576,7 +576,7 @@ shared_ptr<View> Scene::NewView(unsigned int width, unsigned int height, RenderB
 	if((parserTasks.IsDone() == false) || (parserTasks.Failed() == true))
 		throw POV_EXCEPTION_CODE(kNotNowErr);
 
-	return shared_ptr<View>(new View(sceneData, width, height, vid));
+	return boost::shared_ptr<View>(new View(sceneData, width, height, vid));
 }
 
 void Scene::GetStatistics(POVMS_Object& parserStats)
diff --git a/source/backend/scene/scene.h b/source/backend/scene/scene.h
index 60bd649..eca3732 100644
--- a/source/backend/scene/scene.h
+++ b/source/backend/scene/scene.h
@@ -437,7 +437,7 @@ class Scene
 		 *							POVMS messages sent to the frontend.
 		 *	@return					New view bound to the scene's data.
 		 */
-		shared_ptr<View> NewView(unsigned int width, unsigned int height, RenderBackend::ViewId vid);
+		boost::shared_ptr<View> NewView(unsigned int width, unsigned int height, RenderBackend::ViewId vid);
 
 		/**
 		 *	Get the POVMS frontend address to send messages to the frontend.
@@ -458,7 +458,7 @@ class Scene
 		/// scene thread data (i.e. statistics)
 		vector<SceneThreadData *> sceneThreadData;
 		/// scene data
-		shared_ptr<SceneData> sceneData;
+		boost::shared_ptr<SceneData> sceneData;
 		/// stop request flag
 		bool stopRequsted;
 		/// parser control thread
diff --git a/source/backend/scene/threaddata.cpp b/source/backend/scene/threaddata.cpp
index 2468a1f..14f0e44 100644
--- a/source/backend/scene/threaddata.cpp
+++ b/source/backend/scene/threaddata.cpp
@@ -49,7 +49,7 @@
 namespace pov
 {
 
-SceneThreadData::SceneThreadData(shared_ptr<SceneData> sd): sceneData(sd)
+SceneThreadData::SceneThreadData(boost::shared_ptr<SceneData> sd): sceneData(sd)
 {
 	for(int i = 0 ; i < 4 ; i++)
 		Fractal_IStack[i] = NULL;
diff --git a/source/backend/scene/threaddata.h b/source/backend/scene/threaddata.h
index cae34ea..89f66d5 100644
--- a/source/backend/scene/threaddata.h
+++ b/source/backend/scene/threaddata.h
@@ -69,7 +69,7 @@ class SceneThreadData : public Task::TaskData
 		 *	Create thread local data.
 		 *	@param	sd				Scene data defining scene attributes.
 		 */
-		SceneThreadData(shared_ptr<SceneData> sd);
+		SceneThreadData(boost::shared_ptr<SceneData> sd);
 
 		/**
 		 *	Get the statistics.
@@ -153,11 +153,11 @@ class SceneThreadData : public Task::TaskData
 		POV_LONG realTime;
 		unsigned int qualityFlags; // TODO FIXME - remove again
 
-		inline shared_ptr<const SceneData> GetSceneData() const { return sceneData; }
+		inline boost::shared_ptr<const SceneData> GetSceneData() const { return sceneData; }
 
 	protected:
 		/// scene data
-		shared_ptr<SceneData> sceneData;
+		boost::shared_ptr<SceneData> sceneData;
 		/// render statistics
 		RenderStatistics renderStats;
 
diff --git a/source/backend/scene/view.cpp b/source/backend/scene/view.cpp
index e5cfd06..0b0ef48 100644
--- a/source/backend/scene/view.cpp
+++ b/source/backend/scene/view.cpp
@@ -81,7 +81,7 @@ inline unsigned int MakePowerOfTwo(unsigned int i)
 	return 1 << ii;
 }
 
-ViewData::ViewData(shared_ptr<SceneData> sd) :
+ViewData::ViewData(boost::shared_ptr<SceneData> sd) :
 	nextBlock(0),
 	completedFirstPass(false),
 	highestTraceLevel(0),
@@ -569,7 +569,7 @@ RadiosityCache& ViewData::GetRadiosityCache()
 	return radiosityCache;
 }
 
-View::View(shared_ptr<SceneData> sd, unsigned int width, unsigned int height, RenderBackend::ViewId vid) :
+View::View(boost::shared_ptr<SceneData> sd, unsigned int width, unsigned int height, RenderBackend::ViewId vid) :
 	viewData(sd),
 	stopRequsted(false),
 	mailbox(0),
@@ -631,7 +631,7 @@ bool View::CheckCameraHollowObject(const VECTOR point, const BBOX_TREE *node)
 
 bool View::CheckCameraHollowObject(const VECTOR point)
 {
-	shared_ptr<SceneData>& sd = viewData.GetSceneData();
+	boost::shared_ptr<SceneData>& sd = viewData.GetSceneData();
 
 	if(sd->boundingMethod == 2)
 	{
@@ -678,7 +678,7 @@ void View::StartRender(POVMS_Object& renderOptions)
 	unsigned int previewendsize = 0;
 	unsigned int nextblock = 0;
 	bool highReproducibility = false;
-	shared_ptr<set<unsigned int> > blockskiplist(new set<unsigned int>());
+	boost::shared_ptr<set<unsigned int> > blockskiplist(new set<unsigned int>());
 
 	if(renderControlThread == NULL)
 #ifndef USE_OFFICIAL_BOOST
@@ -1382,7 +1382,7 @@ void View::SendStatistics(TaskQueue&)
 	viewThreadData.clear();
 }
 
-void View::SetNextRectangle(TaskQueue&, shared_ptr<set<unsigned int> > bsl, unsigned int fs)
+void View::SetNextRectangle(TaskQueue&, boost::shared_ptr<set<unsigned int> > bsl, unsigned int fs)
 {
 	viewData.SetNextRectangle(*bsl, fs);
 }
diff --git a/source/backend/scene/view.h b/source/backend/scene/view.h
index 887a3cd..b0f2740 100644
--- a/source/backend/scene/view.h
+++ b/source/backend/scene/view.h
@@ -223,7 +223,7 @@ class ViewData
 		 *  Get the scene data for this view.
 		 *  @return                 Scene data.
 		 */
-		inline shared_ptr<SceneData>& GetSceneData() { return sceneData; }
+		inline boost::shared_ptr<SceneData>& GetSceneData() { return sceneData; }
 
 		/**
 		 *  Get the view id for this view.
@@ -322,7 +322,7 @@ class ViewData
 		/// generated radiosity data
 		RadiosityCache radiosityCache;
 		/// scene data
-		shared_ptr<SceneData> sceneData;
+		boost::shared_ptr<SceneData> sceneData;
 		/// view id
 		RenderBackend::ViewId viewId;
 
@@ -346,7 +346,7 @@ class ViewData
 		 *  Create view data.
 		 *  @param  sd              Scene data associated with the view data.
 		 */
-		ViewData(shared_ptr<SceneData> sd);
+		ViewData(boost::shared_ptr<SceneData> sd);
 
 		/**
 		 *  Destructor.
@@ -461,7 +461,7 @@ class View
 		 *  @param  vid             Id of this view to include with
 		 *                          POVMS messages sent to the frontend.
 		 */
-		explicit View(shared_ptr<SceneData> sd, unsigned int width, unsigned int height, RenderBackend::ViewId vid);
+		explicit View(boost::shared_ptr<SceneData> sd, unsigned int width, unsigned int height, RenderBackend::ViewId vid);
 
 		/// not available
 		View& operator=(const View&);
@@ -485,7 +485,7 @@ class View
 		 *  @param  bsl             Block serial numbers to skip.
 		 *  @param  fs              First block to start with checking with serial number.
 		 */
-		void SetNextRectangle(TaskQueue& taskq, shared_ptr<set<unsigned int> > bsl, unsigned int fs);
+		void SetNextRectangle(TaskQueue& taskq, boost::shared_ptr<set<unsigned int> > bsl, unsigned int fs);
 
 		/**
 		 *  Thread controlling the render task queue.
diff --git a/source/backend/shape/truetype.cpp b/source/backend/shape/truetype.cpp
index 7e27ccc..c1e3dd4 100644
--- a/source/backend/shape/truetype.cpp
+++ b/source/backend/shape/truetype.cpp
@@ -336,8 +336,8 @@ ULONG readULONG(IStream *infile, int line, const char *file);
 int compare_tag4(BYTE *ttf_tag, BYTE *known_tag);
 
 /* Internal TTF input routines */
-FontFileInfo *ProcessFontFile(const char *fontfilename, const int font_id, Parser *parser, shared_ptr<SceneData>& sceneData);
-FontFileInfo *OpenFontFile(const char *filename, const int font_id, Parser *parser, shared_ptr<SceneData>& sceneData);
+FontFileInfo *ProcessFontFile(const char *fontfilename, const int font_id, Parser *parser, boost::shared_ptr<SceneData>& sceneData);
+FontFileInfo *OpenFontFile(const char *filename, const int font_id, Parser *parser, boost::shared_ptr<SceneData>& sceneData);
 void ProcessHeadTable(FontFileInfo *ffile, int head_table_offset);
 void ProcessLocaTable(FontFileInfo *ffile, int loca_table_offset);
 void ProcessMaxpTable(FontFileInfo *ffile, int maxp_table_offset);
@@ -451,7 +451,7 @@ int compare_tag4(const BYTE *ttf_tag, const BYTE *known_tag)
 *   (triggered when filename is null) - Oct 2012 [JG]
 *
 ******************************************************************************/
-void TrueType::ProcessNewTTF(CSG *Object, const char *filename, const int font_id, const UCS2 *text_string, DBL depth, const VECTOR offset, Parser *parser, shared_ptr<SceneData>& sceneData)
+void TrueType::ProcessNewTTF(CSG *Object, const char *filename, const int font_id, const UCS2 *text_string, DBL depth, const VECTOR offset, Parser *parser, boost::shared_ptr<SceneData>& sceneData)
 {
 	FontFileInfo *ffile;
 	VECTOR local_offset, total_offset;
@@ -711,7 +711,7 @@ void TrueType::ProcessNewTTF(CSG *Object, const char *filename, const int font_i
 *   Added builtin fonts when fontfilename is nullptr - Oct 2012 [JG]
 *
 ******************************************************************************/
-FontFileInfo *ProcessFontFile(const char *fontfilename, const int font_id, Parser *parser, shared_ptr<SceneData>& sceneData)
+FontFileInfo *ProcessFontFile(const char *fontfilename, const int font_id, Parser *parser, boost::shared_ptr<SceneData>& sceneData)
 {
 	unsigned i;
 	int head_table_offset = 0;
@@ -880,7 +880,7 @@ FontFileInfo *ProcessFontFile(const char *fontfilename, const int font_id, Parse
 *   Added support for builtin fonts - Oct 2012 [JG]
 *
 ******************************************************************************/
-FontFileInfo *OpenFontFile(const char *asciifn, const int font_id, Parser *parser, shared_ptr<SceneData>& sceneData)
+FontFileInfo *OpenFontFile(const char *asciifn, const int font_id, Parser *parser, boost::shared_ptr<SceneData>& sceneData)
 {
 	/* int i; */ /* tw, mtg */
 	FontFileInfo *fontlist = NULL;
diff --git a/source/backend/shape/truetype.h b/source/backend/shape/truetype.h
index 2b28b02..91808b2 100644
--- a/source/backend/shape/truetype.h
+++ b/source/backend/shape/truetype.h
@@ -77,7 +77,7 @@ class TrueType : public ObjectBase
 		virtual void Invert();
 		virtual void Compute_BBox();
 
-		static void ProcessNewTTF(CSG *Object, const char *filename, const int font_id, const UCS2 *text_string, DBL depth, const VECTOR offset, Parser *parser, shared_ptr<SceneData>& sceneData);
+		static void ProcessNewTTF(CSG *Object, const char *filename, const int font_id, const UCS2 *text_string, DBL depth, const VECTOR offset, Parser *parser, boost::shared_ptr<SceneData>& sceneData);
 	protected:
 		bool Inside_Glyph(double x, double y, const GlyphStruct* glyph) const;
 		int solve_quad(double *x, double *y, double mindist, DBL maxdist) const;
diff --git a/source/backend/support/fileutil.cpp b/source/backend/support/fileutil.cpp
index 63b170d..3973389 100644
--- a/source/backend/support/fileutil.cpp
+++ b/source/backend/support/fileutil.cpp
@@ -204,7 +204,7 @@ int InferFileTypeFromExt(const UCS2String& ext) // TODO FIXME - belongs in backe
 *
 ******************************************************************************/
 
-IStream *Locate_File(Parser *p, shared_ptr<SceneData>& sd, const UCS2String& filename, unsigned int stype, UCS2String& buffer, bool err_flag)
+IStream *Locate_File(Parser *p, boost::shared_ptr<SceneData>& sd, const UCS2String& filename, unsigned int stype, UCS2String& buffer, bool err_flag)
 {
 	UCS2String fn(filename);
 	UCS2String foundfile(sd->FindFile(p->GetPOVMSContext(), fn, stype));
@@ -239,7 +239,7 @@ IStream *Locate_File(Parser *p, shared_ptr<SceneData>& sd, const UCS2String& fil
 	return result;
 }
 /* TODO FIXME - code above should not be there, this is how it should work but this has bugs [trf]
-IStream *Locate_File(Parser *p, shared_ptr<SceneData>& sd, const UCS2String& filename, unsigned int stype, UCS2String& buffer, bool err_flag)
+IStream *Locate_File(Parser *p, boost::shared_ptr<SceneData>& sd, const UCS2String& filename, unsigned int stype, UCS2String& buffer, bool err_flag)
 {
 	UCS2String foundfile(sd->FindFile(p->GetPOVMSContext(), filename, stype));
 
diff --git a/source/backend/support/fileutil.h b/source/backend/support/fileutil.h
index 6300be0..976b9b5 100644
--- a/source/backend/support/fileutil.h
+++ b/source/backend/support/fileutil.h
@@ -44,7 +44,7 @@ namespace pov
 
 using namespace pov_base;
 
-IStream *Locate_File(Parser *p, shared_ptr<SceneData>& sd, const UCS2String& filename, unsigned int stype, UCS2String& buffer, bool err_flag = false);
+IStream *Locate_File(Parser *p, boost::shared_ptr<SceneData>& sd, const UCS2String& filename, unsigned int stype, UCS2String& buffer, bool err_flag = false);
 IMemStream *Internal_Font_File(const int font_id, UCS2String& buffer);
 
 }
diff --git a/source/backend/support/imageutil.cpp b/source/backend/support/imageutil.cpp
index 0cb389a..0ed8d65 100644
--- a/source/backend/support/imageutil.cpp
+++ b/source/backend/support/imageutil.cpp
@@ -1381,7 +1381,7 @@ void Destroy_Image(ImageData *image)
 }
 
 
-Image *Read_Image(Parser *p, shared_ptr<SceneData>& sd, int filetype, const UCS2 *filename, const Image::ReadOptions& options)
+Image *Read_Image(Parser *p, boost::shared_ptr<SceneData>& sd, int filetype, const UCS2 *filename, const Image::ReadOptions& options)
 {
 	unsigned int stype;
 	Image::ImageFileType type;
diff --git a/source/backend/support/imageutil.h b/source/backend/support/imageutil.h
index c2fe2d6..4308ac6 100644
--- a/source/backend/support/imageutil.h
+++ b/source/backend/support/imageutil.h
@@ -116,7 +116,7 @@ bool is_image_opaque(const ImageData *image);
 ImageData *Copy_Image(ImageData *old);
 ImageData *Create_Image(void);
 void Destroy_Image(ImageData *image);
-Image *Read_Image(Parser *p, shared_ptr<SceneData>& sd, int filetype, const UCS2 *filename, const Image::ReadOptions& options);
+Image *Read_Image(Parser *p, boost::shared_ptr<SceneData>& sd, int filetype, const UCS2 *filename, const Image::ReadOptions& options);
 
 }
 
diff --git a/source/backend/support/randomsequences.cpp b/source/backend/support/randomsequences.cpp
index ac101bb..1fc6f94 100644
--- a/source/backend/support/randomsequences.cpp
+++ b/source/backend/support/randomsequences.cpp
@@ -228,7 +228,7 @@ class HybridNumberGenerator : public SeedableNumberGenerator<Type>, public Index
 
 		HybridNumberGenerator(size_t size = 0);
 		virtual Type operator()();
-		virtual shared_ptr<vector<Type> > GetSequence(size_t count);
+		virtual boost::shared_ptr<vector<Type> > GetSequence(size_t count);
 		virtual size_t MaxIndex() const;
 		virtual size_t CycleLength() const;
 		virtual void Seed(size_t seed);
@@ -349,8 +349,8 @@ class Halton2dBasedGenerator : public HybridNumberGenerator<Type>
 
 	protected:
 
-		shared_ptr<HaltonDoubleGenerator> generatorA;
-		shared_ptr<HaltonDoubleGenerator> generatorB;
+		boost::shared_ptr<HaltonDoubleGenerator> generatorA;
+		boost::shared_ptr<HaltonDoubleGenerator> generatorB;
 };
 
 /**
@@ -425,22 +425,22 @@ class NumberSequenceFactory
 	public:
 
 		/// Sets up the factory to use a given sequence.
-		NumberSequenceFactory(shared_ptr<vector<Type> const> masterSequence);
+		NumberSequenceFactory(boost::shared_ptr<vector<Type> const> masterSequence);
 		/// Sets up the factory to use a given number source.
-		NumberSequenceFactory(shared_ptr<SequentialNumberGenerator<Type> > master);
+		NumberSequenceFactory(boost::shared_ptr<SequentialNumberGenerator<Type> > master);
 		/// Sets up the factory to use a given number source, pre-computing a given number of elements.
-		NumberSequenceFactory(shared_ptr<SequentialNumberGenerator<Type> > master, size_t count);
+		NumberSequenceFactory(boost::shared_ptr<SequentialNumberGenerator<Type> > master, size_t count);
 		/// Gets a reference to a table of pre-computed numbers having at least the given size.
 		/// @note The vector returned may contain more elements than requested.
-		shared_ptr<vector<Type> const> operator()(size_t count);
+		boost::shared_ptr<vector<Type> const> operator()(size_t count);
 
 	protected:
 
 		typedef SequentialNumberGenerator<Type> Generator;
-		typedef shared_ptr<Generator>           GeneratorPtr;
+		typedef boost::shared_ptr<Generator>           GeneratorPtr;
 		typedef vector<Type>                    Sequence;
-		typedef shared_ptr<Sequence>            SequencePtr;
-		typedef shared_ptr<Sequence const>      SequenceConstPtr;
+		typedef boost::shared_ptr<Sequence>            SequencePtr;
+		typedef boost::shared_ptr<Sequence const>      SequenceConstPtr;
 
 		GeneratorPtr        master;
 		SequenceConstPtr    masterSequence;
@@ -460,12 +460,12 @@ class NumberSequenceMetaFactory
 {
 	public:
 
-		static shared_ptr<NumberSequenceFactory<ValueType> > GetFactory(const typename GeneratorType::ParameterStruct& param);
+		static boost::shared_ptr<NumberSequenceFactory<ValueType> > GetFactory(const typename GeneratorType::ParameterStruct& param);
 
 	protected:
 
 		typedef NumberSequenceFactory<ValueType>    Factory;
-		typedef shared_ptr<Factory>                 FactoryPtr;
+		typedef boost::shared_ptr<Factory>                 FactoryPtr;
 		typedef weak_ptr<Factory>                   FactoryWeakPtr;
 		typedef std::map<typename GeneratorType::ParameterStruct, FactoryWeakPtr> FactoryTable;
 
@@ -492,7 +492,7 @@ class PrecomputedNumberGenerator : public HybridNumberGenerator<Type>
 	public:
 
 		/// Construct from a sequence factory.
-		PrecomputedNumberGenerator(shared_ptr<NumberSequenceFactory<Type> > master, size_t size) :
+		PrecomputedNumberGenerator(boost::shared_ptr<NumberSequenceFactory<Type> > master, size_t size) :
 			HybridNumberGenerator<Type>(size),
 			values((*master)(size))
 		{}
@@ -505,11 +505,11 @@ class PrecomputedNumberGenerator : public HybridNumberGenerator<Type>
 			return (*values)[i % size];
 		}
 		/// Returns a particular subset from the sequence.
-		virtual shared_ptr<vector<Type> > GetSequence(size_t index, size_t count) const
+		virtual boost::shared_ptr<vector<Type> > GetSequence(size_t index, size_t count) const
 		{
 			// According to C++ standard, template classes cannot refer to parent template classes' members by unqualified name
 			const size_t& size = HybridNumberGenerator<Type>::size;
-			shared_ptr<vector<Type> > data(new vector<Type>);
+			boost::shared_ptr<vector<Type> > data(new vector<Type>);
 			data->reserve(count);
 			size_t i = index % size;
 			while (count >= size - i) // handle wrap-around
@@ -524,7 +524,7 @@ class PrecomputedNumberGenerator : public HybridNumberGenerator<Type>
 
 	protected:
 
-		shared_ptr<vector<Type> const> values;
+		boost::shared_ptr<vector<Type> const> values;
 };
 
 typedef PrecomputedNumberGenerator<int>         PrecomputedIntGenerator;
@@ -553,9 +553,9 @@ Type HybridNumberGenerator<Type>::operator()()
 }
 
 template<class Type>
-shared_ptr<vector<Type> > HybridNumberGenerator<Type>::GetSequence(size_t count)
+boost::shared_ptr<vector<Type> > HybridNumberGenerator<Type>::GetSequence(size_t count)
 {
-	shared_ptr<vector<Type> > data(IndexedNumberGenerator<Type>::GetSequence(index, count));
+	boost::shared_ptr<vector<Type> > data(IndexedNumberGenerator<Type>::GetSequence(index, count));
 	index += count;
 	if (size != 0)
 		index = index % size;
@@ -684,24 +684,24 @@ double HaltonGenerator<Type>::operator[](size_t index) const
  *********************************************************************************/
 
 template<class Type>
-NumberSequenceFactory<Type>::NumberSequenceFactory(shared_ptr<vector<Type> const> masterSequence) :
+NumberSequenceFactory<Type>::NumberSequenceFactory(boost::shared_ptr<vector<Type> const> masterSequence) :
 	masterSequence(masterSequence)
 {}
 
 template<class Type>
-NumberSequenceFactory<Type>::NumberSequenceFactory(shared_ptr<SequentialNumberGenerator<Type> > master) :
+NumberSequenceFactory<Type>::NumberSequenceFactory(boost::shared_ptr<SequentialNumberGenerator<Type> > master) :
 	master(master)
 {}
 
 template<class Type>
-NumberSequenceFactory<Type>::NumberSequenceFactory(shared_ptr<SequentialNumberGenerator<Type> > master, size_t count) :
+NumberSequenceFactory<Type>::NumberSequenceFactory(boost::shared_ptr<SequentialNumberGenerator<Type> > master, size_t count) :
 	master(master)
 {
 	(*this)(count); // force initial sequence to be generated
 }
 
 template<class Type>
-shared_ptr<vector<Type> const> NumberSequenceFactory<Type>::operator()(size_t count)
+boost::shared_ptr<vector<Type> const> NumberSequenceFactory<Type>::operator()(size_t count)
 {
 	boost::mutex::scoped_lock lock(masterMutex);
 	if (!masterSequence)
@@ -747,7 +747,7 @@ template<class ValueType, class GeneratorType>
 boost::mutex NumberSequenceMetaFactory<ValueType, GeneratorType>::lookupMutex;
 
 template<class ValueType, class GeneratorType>
-shared_ptr<NumberSequenceFactory<ValueType> > NumberSequenceMetaFactory<ValueType, GeneratorType>::GetFactory(const typename GeneratorType::ParameterStruct& param)
+boost::shared_ptr<NumberSequenceFactory<ValueType> > NumberSequenceMetaFactory<ValueType, GeneratorType>::GetFactory(const typename GeneratorType::ParameterStruct& param)
 {
 	boost::mutex::scoped_lock lock(lookupMutex);
 	if (!lookupTable)
@@ -755,8 +755,8 @@ shared_ptr<NumberSequenceFactory<ValueType> > NumberSequenceMetaFactory<ValueTyp
 	FactoryPtr factory = (*lookupTable)[param].lock();
 	if (!factory)
 	{
-		shared_ptr<GeneratorType> masterGenerator(new GeneratorType(param));
-		factory = FactoryPtr(new Factory(shared_ptr<SequentialNumberGenerator<ValueType> >(masterGenerator)));
+		boost::shared_ptr<GeneratorType> masterGenerator(new GeneratorType(param));
+		factory = FactoryPtr(new Factory(boost::shared_ptr<SequentialNumberGenerator<ValueType> >(masterGenerator)));
 		(*lookupTable)[param] = factory;
 	}
 	return factory;
@@ -912,7 +912,7 @@ SeedableIntGeneratorPtr GetRandomIntGenerator(int minval, int maxval, size_t cou
 {
 	assert (count > 0);
 	Mt19937IntGenerator::ParameterStruct param(minval, maxval);
-	shared_ptr<NumberSequenceFactory<int> > factory = Mt19937IntMetaFactory::GetFactory(param);
+	boost::shared_ptr<NumberSequenceFactory<int> > factory = Mt19937IntMetaFactory::GetFactory(param);
 	SeedableIntGeneratorPtr generator(new PrecomputedIntGenerator(factory, count));
 	(void)(*generator)(); // legacy fix
 	return generator;
@@ -922,7 +922,7 @@ SeedableDoubleGeneratorPtr GetRandomDoubleGenerator(double minval, double maxval
 {
 	assert (count > 0);
 	Mt19937DoubleGenerator::ParameterStruct param(minval, maxval);
-	shared_ptr<NumberSequenceFactory<double> > factory(Mt19937DoubleMetaFactory::GetFactory(param));
+	boost::shared_ptr<NumberSequenceFactory<double> > factory(Mt19937DoubleMetaFactory::GetFactory(param));
 	SeedableDoubleGeneratorPtr generator(new PrecomputedDoubleGenerator(factory, count));
 	(void)(*generator)(); // legacy fix
 	return generator;
@@ -940,7 +940,7 @@ IndexedDoubleGeneratorPtr GetIndexedRandomDoubleGenerator(double minval, double
 {
 	assert (count > 0);
 	Mt19937DoubleGenerator::ParameterStruct param(minval, maxval);
-	shared_ptr<NumberSequenceFactory<double> > factory(Mt19937DoubleMetaFactory::GetFactory(param));
+	boost::shared_ptr<NumberSequenceFactory<double> > factory(Mt19937DoubleMetaFactory::GetFactory(param));
 	return IndexedDoubleGeneratorPtr(new PrecomputedDoubleGenerator(factory, count));
 }
 
@@ -949,7 +949,7 @@ SequentialVectorGeneratorPtr GetSubRandomCosWeightedDirectionGenerator(unsigned
 	if ((id == 0) && count && (count < LegacyCosWeightedDirectionGenerator::NumEntries))
 	{
 		LegacyCosWeightedDirectionGenerator::ParameterStruct param;
-		shared_ptr<NumberSequenceFactory<Vector3d> > factory(LegacyCosWeightedDirectionMetaFactory::GetFactory(param));
+		boost::shared_ptr<NumberSequenceFactory<Vector3d> > factory(LegacyCosWeightedDirectionMetaFactory::GetFactory(param));
 		return SequentialVectorGeneratorPtr(new PrecomputedVectorGenerator(factory, count));
 	}
 	else
@@ -957,7 +957,7 @@ SequentialVectorGeneratorPtr GetSubRandomCosWeightedDirectionGenerator(unsigned
 		HaltonCosWeightedDirectionGenerator::ParameterStruct param(primeTable[id % PRIME_TABLE_COUNT], primeTable[(id+1) % PRIME_TABLE_COUNT]);
 		if (count)
 		{
-			shared_ptr<NumberSequenceFactory<Vector3d> > factory(HaltonCosWeightedDirectionMetaFactory::GetFactory(param));
+			boost::shared_ptr<NumberSequenceFactory<Vector3d> > factory(HaltonCosWeightedDirectionMetaFactory::GetFactory(param));
 			return SequentialVectorGeneratorPtr(new PrecomputedVectorGenerator(factory, count));
 		}
 		else
@@ -970,7 +970,7 @@ SequentialDoubleGeneratorPtr GetSubRandomDoubleGenerator(unsigned int id, double
 	HaltonDoubleGenerator::ParameterStruct param(primeTable[id % PRIME_TABLE_COUNT], minval, maxval);
 	if (count)
 	{
-		shared_ptr<NumberSequenceFactory<double> > factory(HaltonUniformDoubleMetaFactory::GetFactory(param));
+		boost::shared_ptr<NumberSequenceFactory<double> > factory(HaltonUniformDoubleMetaFactory::GetFactory(param));
 		return SequentialDoubleGeneratorPtr(new PrecomputedDoubleGenerator(factory, count));
 	}
 	else
@@ -982,7 +982,7 @@ SequentialVectorGeneratorPtr GetSubRandomDirectionGenerator(unsigned int id, siz
 	HaltonUniformDirectionGenerator::ParameterStruct param(primeTable[id % PRIME_TABLE_COUNT], primeTable[(id+1) % PRIME_TABLE_COUNT]);
 	if (count)
 	{
-		shared_ptr<NumberSequenceFactory<Vector3d> > factory(HaltonUniformDirectionMetaFactory::GetFactory(param));
+		boost::shared_ptr<NumberSequenceFactory<Vector3d> > factory(HaltonUniformDirectionMetaFactory::GetFactory(param));
 		return SequentialVectorGeneratorPtr(new PrecomputedVectorGenerator(factory, count));
 	}
 	else
@@ -994,7 +994,7 @@ SequentialVector2dGeneratorPtr GetSubRandomOnDiscGenerator(unsigned int id, doub
 	HaltonOnDiscGenerator::ParameterStruct param(primeTable[id % PRIME_TABLE_COUNT], primeTable[(id+1) % PRIME_TABLE_COUNT], radius);
 	if (count)
 	{
-		shared_ptr<NumberSequenceFactory<Vector2d> > factory(HaltonOnDiscMetaFactory::GetFactory(param));
+		boost::shared_ptr<NumberSequenceFactory<Vector2d> > factory(HaltonOnDiscMetaFactory::GetFactory(param));
 		return SequentialVector2dGeneratorPtr(new PrecomputedVector2dGenerator(factory, count));
 	}
 	else
@@ -1006,7 +1006,7 @@ SequentialVector2dGeneratorPtr GetSubRandom2dGenerator(unsigned int id, double m
 	Halton2dGenerator::ParameterStruct param(primeTable[id % PRIME_TABLE_COUNT], primeTable[(id+1) % PRIME_TABLE_COUNT], minX, maxX, minY, maxY);
 	if (count)
 	{
-		shared_ptr<NumberSequenceFactory<Vector2d> > factory(Halton2dMetaFactory::GetFactory(param));
+		boost::shared_ptr<NumberSequenceFactory<Vector2d> > factory(Halton2dMetaFactory::GetFactory(param));
 		return SequentialVector2dGeneratorPtr(new PrecomputedVector2dGenerator(factory, count));
 	}
 	else
diff --git a/source/backend/support/randomsequences.h b/source/backend/support/randomsequences.h
index f0402ef..d796d35 100644
--- a/source/backend/support/randomsequences.h
+++ b/source/backend/support/randomsequences.h
@@ -118,9 +118,9 @@ class SequentialNumberGenerator
 		/// Returns the next number from the sequence.
 		virtual Type operator()() = 0;
 		/// Returns the next N numbers from the sequence.
-		virtual shared_ptr<vector<Type> > GetSequence(size_t count)
+		virtual boost::shared_ptr<vector<Type> > GetSequence(size_t count)
 		{
-			shared_ptr<vector<Type> > data(new vector<Type>);
+			boost::shared_ptr<vector<Type> > data(new vector<Type>);
 			data->reserve(count);
 			for (size_t i = 0; i < count; i ++)
 				data->push_back((*this)());
@@ -147,9 +147,9 @@ class IndexedNumberGenerator
 		/// Returns a particular number from the sequence.
 		virtual Type operator[](size_t index) const = 0;
 		/// Returns a particular subsequence from the sequence.
-		virtual shared_ptr<vector<Type> > GetSequence(size_t index, size_t count) const
+		virtual boost::shared_ptr<vector<Type> > GetSequence(size_t index, size_t count) const
 		{
-			shared_ptr<vector<Type> > data(new vector<Type>);
+			boost::shared_ptr<vector<Type> > data(new vector<Type>);
 			data->reserve(count);
 			for (size_t i = 0; i < count; i ++)
 				data->push_back((*this)[index + i]);
@@ -172,20 +172,20 @@ class IndexedNumberGenerator
  *  @{
  */
 
-typedef shared_ptr<SequentialNumberGenerator<int> >         SequentialIntGeneratorPtr;
-typedef shared_ptr<SequentialNumberGenerator<double> >      SequentialDoubleGeneratorPtr;
-typedef shared_ptr<SequentialNumberGenerator<Vector3d> >    SequentialVectorGeneratorPtr;
-typedef shared_ptr<SequentialNumberGenerator<Vector2d> >    SequentialVector2dGeneratorPtr;
+typedef boost::shared_ptr<SequentialNumberGenerator<int> >         SequentialIntGeneratorPtr;
+typedef boost::shared_ptr<SequentialNumberGenerator<double> >      SequentialDoubleGeneratorPtr;
+typedef boost::shared_ptr<SequentialNumberGenerator<Vector3d> >    SequentialVectorGeneratorPtr;
+typedef boost::shared_ptr<SequentialNumberGenerator<Vector2d> >    SequentialVector2dGeneratorPtr;
 
-typedef shared_ptr<SeedableNumberGenerator<int> >           SeedableIntGeneratorPtr;
-typedef shared_ptr<SeedableNumberGenerator<double> >        SeedableDoubleGeneratorPtr;
-typedef shared_ptr<SeedableNumberGenerator<Vector3d> >      SeedableVectorGeneratorPtr;
-typedef shared_ptr<SeedableNumberGenerator<Vector2d> >      SeedableVector2dGeneratorPtr;
+typedef boost::shared_ptr<SeedableNumberGenerator<int> >           SeedableIntGeneratorPtr;
+typedef boost::shared_ptr<SeedableNumberGenerator<double> >        SeedableDoubleGeneratorPtr;
+typedef boost::shared_ptr<SeedableNumberGenerator<Vector3d> >      SeedableVectorGeneratorPtr;
+typedef boost::shared_ptr<SeedableNumberGenerator<Vector2d> >      SeedableVector2dGeneratorPtr;
 
-typedef shared_ptr<IndexedNumberGenerator<int> const>       IndexedIntGeneratorPtr;
-typedef shared_ptr<IndexedNumberGenerator<double> const>    IndexedDoubleGeneratorPtr;
-typedef shared_ptr<IndexedNumberGenerator<Vector3d> const>  IndexedVectorGeneratorPtr;
-typedef shared_ptr<IndexedNumberGenerator<Vector2d> const>  IndexedVector2dGeneratorPtr;
+typedef boost::shared_ptr<IndexedNumberGenerator<int> const>       IndexedIntGeneratorPtr;
+typedef boost::shared_ptr<IndexedNumberGenerator<double> const>    IndexedDoubleGeneratorPtr;
+typedef boost::shared_ptr<IndexedNumberGenerator<Vector3d> const>  IndexedVectorGeneratorPtr;
+typedef boost::shared_ptr<IndexedNumberGenerator<Vector2d> const>  IndexedVector2dGeneratorPtr;
 
 /**
  *  @}
diff --git a/source/backend/support/taskqueue.cpp b/source/backend/support/taskqueue.cpp
index 8179310..86a18da 100644
--- a/source/backend/support/taskqueue.cpp
+++ b/source/backend/support/taskqueue.cpp
@@ -149,7 +149,7 @@ Task::TaskData *TaskQueue::AppendTask(Task *task)
 
 	failed = false;
 
-	queuedTasks.push(TaskEntry(shared_ptr<Task>(task)));
+	queuedTasks.push(TaskEntry(boost::shared_ptr<Task>(task)));
 
 	Notify();
 
diff --git a/source/backend/support/taskqueue.h b/source/backend/support/taskqueue.h
index 09f8642..769b501 100644
--- a/source/backend/support/taskqueue.h
+++ b/source/backend/support/taskqueue.h
@@ -57,19 +57,19 @@ class TaskQueue
 				};
 
 				TaskEntry(EntryType et) : entryType(et) { }
-				TaskEntry(shared_ptr<Task> rt) : entryType(kTask), task(rt) { }
+				TaskEntry(boost::shared_ptr<Task> rt) : entryType(kTask), task(rt) { }
 				TaskEntry(POVMS_Message& m) : entryType(kMessage), msg(m) { }
 				TaskEntry(const boost::function1<void, TaskQueue&>& f) : entryType(kFunction), fn(f) { }
 				~TaskEntry() { }
 
-				shared_ptr<Task> GetTask() { return task; }
+				boost::shared_ptr<Task> GetTask() { return task; }
 				POVMS_Message& GetMessage() { return msg; }
 				boost::function1<void, TaskQueue&>& GetFunction() { return fn; }
 
 				EntryType GetEntryType() { return entryType; }
 			private:
 				EntryType entryType;
-				shared_ptr<Task> task;
+				boost::shared_ptr<Task> task;
 				POVMS_Message msg;
 				boost::function1<void, TaskQueue&> fn;
 		};
diff --git a/source/base/image/colourspace.cpp b/source/base/image/colourspace.cpp
index 205db3c..ad3df9a 100644
--- a/source/base/image/colourspace.cpp
+++ b/source/base/image/colourspace.cpp
@@ -110,7 +110,7 @@ GammaCurvePtr GammaCurve::GetMatching(const GammaCurvePtr& newInstance)
 		else if (oldInstance->Matches(newInstance))
 		{
 			// Found a matching curve in the cache, so use that instead, and (as far as we're concerned)
-			// just forget that the new instance ever existed (allowing the shared_ptr mechanism to garbage-collect it)
+			// just forget that the new instance ever existed (allowing the boost::shared_ptr mechanism to garbage-collect it)
 			return oldInstance;
 		}
 	}
diff --git a/source/frontend/imageprocessing.cpp b/source/frontend/imageprocessing.cpp
index fd98381..a7997bb 100644
--- a/source/frontend/imageprocessing.cpp
+++ b/source/frontend/imageprocessing.cpp
@@ -62,7 +62,7 @@ enum
 
 ImageProcessing::ImageProcessing(unsigned int width, unsigned int height)
 {
-	image = shared_ptr<Image>(Image::Create(width, height, Image::RGBFT_Float));
+	image = boost::shared_ptr<Image>(Image::Create(width, height, Image::RGBFT_Float));
 	toStderr = toStdout = false;
 
 	// TODO FIXME - find a better place for this
@@ -76,7 +76,7 @@ ImageProcessing::ImageProcessing(POVMS_Object& ropts)
 	unsigned int blockSize(ropts.TryGetInt(kPOVAttrib_RenderBlockSize, 32));
 	unsigned int maxBufferMem(ropts.TryGetInt(kPOVAttrib_MaxImageBufferMem, 128)); // number is megabytes
 
-	image = shared_ptr<Image>(Image::Create(width, height, Image::RGBFT_Float, maxBufferMem, blockSize * blockSize));
+	image = boost::shared_ptr<Image>(Image::Create(width, height, Image::RGBFT_Float, maxBufferMem, blockSize * blockSize));
 	toStdout = OutputIsStdout(ropts);
 	toStderr = OutputIsStderr(ropts);
 
@@ -84,7 +84,7 @@ ImageProcessing::ImageProcessing(POVMS_Object& ropts)
 	image->SetPremultiplied(true); // POV-Ray uses premultiplied opacity for its math, so that's what will end up in the image container
 }
 
-ImageProcessing::ImageProcessing(shared_ptr<Image>& img)
+ImageProcessing::ImageProcessing(boost::shared_ptr<Image>& img)
 {
 	image = img;
 	toStderr = toStdout = false;
@@ -187,7 +187,7 @@ UCS2String ImageProcessing::WriteImage(POVMS_Object& ropts, POVMSInt frame, int
 		return UCS2String();
 }
 
-shared_ptr<Image>& ImageProcessing::GetImage()
+boost::shared_ptr<Image>& ImageProcessing::GetImage()
 {
 	return image;
 }
diff --git a/source/frontend/imageprocessing.h b/source/frontend/imageprocessing.h
index dc568b2..c3baaf5 100644
--- a/source/frontend/imageprocessing.h
+++ b/source/frontend/imageprocessing.h
@@ -53,12 +53,12 @@ class ImageProcessing
 	public:
 		ImageProcessing(unsigned int width, unsigned int height);
 		ImageProcessing(POVMS_Object& ropts);
-		ImageProcessing(shared_ptr<Image>& img);
+		ImageProcessing(boost::shared_ptr<Image>& img);
 		virtual ~ImageProcessing();
 
 		UCS2String WriteImage(POVMS_Object& ropts, POVMSInt frame = 0, int digits = 0);
 
-		shared_ptr<Image>& GetImage();
+		boost::shared_ptr<Image>& GetImage();
 
 		UCS2String GetOutputFilename(POVMS_Object& ropts, POVMSInt frame, int digits);
 		bool OutputIsStdout(void) { return toStdout; }
@@ -66,7 +66,7 @@ class ImageProcessing
 		virtual bool OutputIsStdout(POVMS_Object& ropts);
 		virtual bool OutputIsStderr(POVMS_Object& ropts);
 	protected:
-		shared_ptr<Image> image;
+		boost::shared_ptr<Image> image;
 		bool toStdout;
 		bool toStderr;
 
diff --git a/source/frontend/renderfrontend.cpp b/source/frontend/renderfrontend.cpp
index 1c9b646..289ae35 100644
--- a/source/frontend/renderfrontend.cpp
+++ b/source/frontend/renderfrontend.cpp
@@ -143,7 +143,7 @@ RenderFrontendBase::~RenderFrontendBase()
 	// nothing to do
 }
 
-void RenderFrontendBase::ConnectToBackend(POVMSAddress backendaddress, POVMS_Object& obj, POVMS_Object *resultobj, shared_ptr<Console>& console)
+void RenderFrontendBase::ConnectToBackend(POVMSAddress backendaddress, POVMS_Object& obj, POVMS_Object *resultobj, boost::shared_ptr<Console>& console)
 {
 	POVMS_Message msg(obj, kPOVMsgClass_BackendControl, kPOVMsgIdent_InitInfo);
 	POVMS_Message result(kPOVObjectClass_ResultData);
@@ -605,7 +605,7 @@ void RenderFrontendBase::NewBackup(POVMS_Object& ropts, ViewData& vd, const Path
 	MakeBackupPath(ropts, vd, outputpath);
 	if(POV_ALLOW_FILE_WRITE(vd.imageBackupFile().c_str(), POV_File_Data_Backup) == false)
 		throw POV_EXCEPTION(kCannotOpenFileErr, "Permission denied to create render state output file.");
-	vd.imageBackup = shared_ptr<OStream>(POV_PLATFORM_BASE.CreateOStream(POV_File_Data_Backup));
+	vd.imageBackup = boost::shared_ptr<OStream>(POV_PLATFORM_BASE.CreateOStream(POV_File_Data_Backup));
 	if(vd.imageBackup != NULL)
 	{
 		Backup_File_Header hdr;
@@ -720,7 +720,7 @@ void RenderFrontendBase::ContinueBackup(POVMS_Object& ropts, ViewData& vd, ViewI
 	// if there isn't going to be an output file, we don't write to the state file
 	if(outputToFile == true)
 	{
-		vd.imageBackup = shared_ptr<OStream>(POV_PLATFORM_BASE.CreateOStream(POV_File_Data_Backup));
+		vd.imageBackup = boost::shared_ptr<OStream>(POV_PLATFORM_BASE.CreateOStream(POV_File_Data_Backup));
 		if(vd.imageBackup != NULL)
 		{
 			if(vd.imageBackup->open(vd.imageBackupFile().c_str(), IOBase::append) == false)
diff --git a/source/frontend/renderfrontend.h b/source/frontend/renderfrontend.h
index 797dad1..e95df77 100644
--- a/source/frontend/renderfrontend.h
+++ b/source/frontend/renderfrontend.h
@@ -93,7 +93,7 @@ struct SceneData
 
 	SceneState state;
 
-	mutable shared_ptr<Console> console;
+	mutable boost::shared_ptr<Console> console;
 
 	mutable list<POVMS_Object> readfiles;
 	mutable list<POVMS_Object> createdfiles;
@@ -103,7 +103,7 @@ struct SceneData
 
 	list<Path> searchpaths;
 
-	shared_ptr<TextStreamBuffer> streams[MAX_STREAMS];
+	boost::shared_ptr<TextStreamBuffer> streams[MAX_STREAMS];
 
 	UCS2String streamnames[MAX_STREAMS];
 	bool consoleoutput[MAX_STREAMS];
@@ -136,9 +136,9 @@ struct ViewData
 
 	ViewState state;
 
-	mutable shared_ptr<Image> image;
-	mutable shared_ptr<Display> display;
-	mutable shared_ptr<OStream> imageBackup;
+	mutable boost::shared_ptr<Image> image;
+	mutable boost::shared_ptr<Display> display;
+	mutable boost::shared_ptr<OStream> imageBackup;
 
 	Path imageBackupFile;
 };
@@ -219,12 +219,12 @@ class RenderFrontendBase : public POVMS_MessageReceiver
 		RenderFrontendBase(POVMSContext);
 		virtual ~RenderFrontendBase();
 
-		void ConnectToBackend(POVMSAddress, POVMS_Object&, POVMS_Object *, shared_ptr<Console>&);
+		void ConnectToBackend(POVMSAddress, POVMS_Object&, POVMS_Object *, boost::shared_ptr<Console>&);
 		void DisconnectFromBackend(POVMSAddress);
 
-		virtual shared_ptr<Console> GetConsole(SceneId) = 0;
-		virtual shared_ptr<Image> GetImage(ViewId) = 0;
-		virtual shared_ptr<Display> GetDisplay(ViewId) = 0;
+		virtual boost::shared_ptr<Console> GetConsole(SceneId) = 0;
+		virtual boost::shared_ptr<Image> GetImage(ViewId) = 0;
+		virtual boost::shared_ptr<Display> GetDisplay(ViewId) = 0;
 	protected:
 		set<POVMSAddress> backendaddresses;
 		POVMSContext context;
@@ -291,7 +291,7 @@ class RenderFrontend : public RenderFrontendBase
 		void ResumeParser(SceneId sid);
 		void StopParser(SceneId sid);
 
-		ViewId CreateView(SceneId sid, POVMS_Object& obj, shared_ptr<ImageProcessing>& imageProcessing, boost::function<Display *(unsigned int, unsigned int, GammaCurvePtr)> fn);
+		ViewId CreateView(SceneId sid, POVMS_Object& obj, boost::shared_ptr<ImageProcessing>& imageProcessing, boost::function<Display *(unsigned int, unsigned int, GammaCurvePtr)> fn);
 		void CloseView(ViewId vid);
 
 		ViewData::ViewState GetViewState(ViewId vid);
@@ -301,9 +301,9 @@ class RenderFrontend : public RenderFrontendBase
 		void ResumeRender(ViewId vid);
 		void StopRender(ViewId vid);
 
-		virtual shared_ptr<Console> GetConsole(SceneId sid);
-		virtual shared_ptr<Image> GetImage(ViewId vid);
-		virtual shared_ptr<Display> GetDisplay(ViewId vid);
+		virtual boost::shared_ptr<Console> GetConsole(SceneId sid);
+		virtual boost::shared_ptr<Image> GetImage(ViewId vid);
+		virtual boost::shared_ptr<Display> GetDisplay(ViewId vid);
 	protected:
 		virtual void HandleParserMessage(SceneId sid, POVMSType ident, POVMS_Object& msg);
 		virtual void HandleFileMessage(SceneId sid, POVMSType ident, POVMS_Object& msg, POVMS_Object& result);
@@ -344,7 +344,7 @@ RenderFrontendBase::SceneId RenderFrontend<PARSER_MH, FILE_MH, RENDER_MH, IMAGE_
 
 		sid = RenderFrontendBase::CreateScene(sh.data, backendaddress, obj);
 
-		sh.data.console = shared_ptr<Console>(fn());
+		sh.data.console = boost::shared_ptr<Console>(fn());
 
 		scenehandler[sid] = sh;
 		scene2views[sid] = set<ViewId>();
@@ -434,7 +434,7 @@ void RenderFrontend<PARSER_MH, FILE_MH, RENDER_MH, IMAGE_MH>::StopParser(SceneId
 }
 
 template<class PARSER_MH, class FILE_MH, class RENDER_MH, class IMAGE_MH>
-RenderFrontendBase::ViewId RenderFrontend<PARSER_MH, FILE_MH, RENDER_MH, IMAGE_MH>::CreateView(SceneId sid, POVMS_Object& obj, shared_ptr<ImageProcessing>& imageProcessing, boost::function<Display *(unsigned int,unsigned int,GammaCurvePtr)> fn)
+RenderFrontendBase::ViewId RenderFrontend<PARSER_MH, FILE_MH, RENDER_MH, IMAGE_MH>::CreateView(SceneId sid, POVMS_Object& obj, boost::shared_ptr<ImageProcessing>& imageProcessing, boost::function<Display *(unsigned int,unsigned int,GammaCurvePtr)> fn)
 {
 	typename map<SceneId, SceneHandler>::iterator shi(scenehandler.find(sid));
 
@@ -530,7 +530,7 @@ RenderFrontendBase::ViewId RenderFrontend<PARSER_MH, FILE_MH, RENDER_MH, IMAGE_M
 			{
 				if (imageProcessing == NULL)
 					throw POV_EXCEPTION(kNullPointerErr, "Internal error: output to file is set, but no ImageProcessing object supplied");
-				shared_ptr<Image> img(imageProcessing->GetImage());
+				boost::shared_ptr<Image> img(imageProcessing->GetImage());
 				if(img != NULL)
 				{
 					if((img->GetWidth() != width) || (img->GetHeight() != height))
@@ -539,11 +539,11 @@ RenderFrontendBase::ViewId RenderFrontend<PARSER_MH, FILE_MH, RENDER_MH, IMAGE_M
 					vh.data.image = img;
 				}
 				else
-					vh.data.image = shared_ptr<Image>(Image::Create(width, height, Image::RGBFT_Float));
+					vh.data.image = boost::shared_ptr<Image>(Image::Create(width, height, Image::RGBFT_Float));
 			}
 
 			if(obj.TryGetBool(kPOVAttrib_Display, true) == true)
-				vh.data.display = shared_ptr<Display>(fn(width, height, gamma));
+				vh.data.display = boost::shared_ptr<Display>(fn(width, height, gamma));
 
 			viewhandler[vid] = vh;
 			view2scene[vid] = sid;
@@ -717,33 +717,33 @@ void RenderFrontend<PARSER_MH, FILE_MH, RENDER_MH, IMAGE_MH>::StopRender(ViewId
 }
 
 template<class PARSER_MH, class FILE_MH, class RENDER_MH, class IMAGE_MH>
-shared_ptr<Console> RenderFrontend<PARSER_MH, FILE_MH, RENDER_MH, IMAGE_MH>::GetConsole(SceneId sid)
+boost::shared_ptr<Console> RenderFrontend<PARSER_MH, FILE_MH, RENDER_MH, IMAGE_MH>::GetConsole(SceneId sid)
 {
 	typename map<SceneId, SceneHandler>::iterator shi(scenehandler.find(sid));
 	if(shi != scenehandler.end())
 		return shi->second.data.console;
 	else
-		return shared_ptr<Console>();
+		return boost::shared_ptr<Console>();
 }
 
 template<class PARSER_MH, class FILE_MH, class RENDER_MH, class IMAGE_MH>
-shared_ptr<Image> RenderFrontend<PARSER_MH, FILE_MH, RENDER_MH, IMAGE_MH>::GetImage(ViewId vid)
+boost::shared_ptr<Image> RenderFrontend<PARSER_MH, FILE_MH, RENDER_MH, IMAGE_MH>::GetImage(ViewId vid)
 {
 	typename map<ViewId, ViewHandler>::iterator vhi(viewhandler.find(vid));
 	if(vhi != viewhandler.end())
 		return vhi->second.data.image;
 	else
-		return shared_ptr<Image>();
+		return boost::shared_ptr<Image>();
 }
 
 template<class PARSER_MH, class FILE_MH, class RENDER_MH, class IMAGE_MH>
-shared_ptr<Display> RenderFrontend<PARSER_MH, FILE_MH, RENDER_MH, IMAGE_MH>::GetDisplay(ViewId vid)
+boost::shared_ptr<Display> RenderFrontend<PARSER_MH, FILE_MH, RENDER_MH, IMAGE_MH>::GetDisplay(ViewId vid)
 {
 	typename map<ViewId, ViewHandler>::iterator vhi(viewhandler.find(vid));
 	if(vhi != viewhandler.end())
 		return vhi->second.data.display;
 	else
-		return shared_ptr<Display>();
+		return boost::shared_ptr<Display>();
 }
 
 template<class PARSER_MH, class FILE_MH, class RENDER_MH, class IMAGE_MH>
diff --git a/source/frontend/simplefrontend.h b/source/frontend/simplefrontend.h
index 5a4766f..e632cc2 100644
--- a/source/frontend/simplefrontend.h
+++ b/source/frontend/simplefrontend.h
@@ -73,10 +73,10 @@ class SimpleFrontend
 		SimpleFrontend(POVMSContext ctx, POVMSAddress addr, POVMS_Object& msg,
 		               boost::function<Console *()> cfn,
 		               boost::function<Display *(unsigned int, unsigned int, GammaCurvePtr)> dfn,
-		               POVMS_Object *result = NULL, shared_ptr<Console> console = shared_ptr<Console>());
+		               POVMS_Object *result = NULL, boost::shared_ptr<Console> console = boost::shared_ptr<Console>());
 		~SimpleFrontend();
 
-		bool Start(POVMS_Object& opts, shared_ptr<Image> img = shared_ptr<Image>());
+		bool Start(POVMS_Object& opts, boost::shared_ptr<Image> img = boost::shared_ptr<Image>());
 		bool Stop();
 		bool Pause();
 		bool Resume();
@@ -85,9 +85,9 @@ class SimpleFrontend
 
 		State GetState() const;
 
-		shared_ptr<Console> GetConsole();
-		shared_ptr<Image> GetImage();
-		shared_ptr<Display> GetDisplay();
+		boost::shared_ptr<Console> GetConsole();
+		boost::shared_ptr<Image> GetImage();
+		boost::shared_ptr<Display> GetDisplay();
 	private:
 		RenderFrontend<PARSER_MH, FILE_MH, RENDER_MH, IMAGE_MH> renderFrontend;
 		POVMSAddress backendAddress;
@@ -95,9 +95,9 @@ class SimpleFrontend
 		POVMS_Object options;
 		RenderFrontendBase::SceneId sceneId;
 		RenderFrontendBase::ViewId viewId;
-		shared_ptr<ImageProcessing> imageProcessing;
-		shared_ptr<AnimationProcessing> animationProcessing;
-		shared_ptr<ShelloutProcessing> shelloutProcessing;
+		boost::shared_ptr<ImageProcessing> imageProcessing;
+		boost::shared_ptr<AnimationProcessing> animationProcessing;
+		boost::shared_ptr<ShelloutProcessing> shelloutProcessing;
 		boost::function<Console *()> createConsole;
 		boost::function<Display *(unsigned int, unsigned int, GammaCurvePtr)> createDisplay;
 };
@@ -106,7 +106,7 @@ template<class PARSER_MH, class FILE_MH, class RENDER_MH, class IMAGE_MH>
 SimpleFrontend<PARSER_MH, FILE_MH, RENDER_MH, IMAGE_MH>::SimpleFrontend(POVMSContext ctx, POVMSAddress addr, POVMS_Object& msg,
                                                                         boost::function<Console *()> cfn,
                                                                         boost::function<Display *(unsigned int, unsigned int, GammaCurvePtr)> dfn,
-                                                                        POVMS_Object *result, shared_ptr<Console> console) :
+                                                                        POVMS_Object *result, boost::shared_ptr<Console> console) :
 	renderFrontend(ctx),
 	backendAddress(addr),
 	state(kReady),
@@ -124,7 +124,7 @@ SimpleFrontend<PARSER_MH, FILE_MH, RENDER_MH, IMAGE_MH>::~SimpleFrontend()
 }
 
 template<class PARSER_MH, class FILE_MH, class RENDER_MH, class IMAGE_MH>
-bool SimpleFrontend<PARSER_MH, FILE_MH, RENDER_MH, IMAGE_MH>::Start(POVMS_Object& opts, shared_ptr<Image> img)
+bool SimpleFrontend<PARSER_MH, FILE_MH, RENDER_MH, IMAGE_MH>::Start(POVMS_Object& opts, boost::shared_ptr<Image> img)
 {
 	int width;
 	int height;
@@ -151,16 +151,16 @@ bool SimpleFrontend<PARSER_MH, FILE_MH, RENDER_MH, IMAGE_MH>::Start(POVMS_Object
 	opts.Set(kPOVAttrib_Declare, declares);
 
 	if(opts.TryGetInt(kPOVAttrib_FinalFrame, 0) > 0)
-		animationProcessing = shared_ptr<AnimationProcessing>(new AnimationProcessing(opts));
+		animationProcessing = boost::shared_ptr<AnimationProcessing>(new AnimationProcessing(opts));
 
 	options = opts;
 
 	if(opts.TryGetBool(kPOVAttrib_OutputToFile, true))
 	{
 		if(img != NULL)
-			imageProcessing = shared_ptr<ImageProcessing>(new ImageProcessing(img));
+			imageProcessing = boost::shared_ptr<ImageProcessing>(new ImageProcessing(img));
 		else
-			imageProcessing = shared_ptr<ImageProcessing>(new ImageProcessing(options));
+			imageProcessing = boost::shared_ptr<ImageProcessing>(new ImageProcessing(options));
 	}
 
 	Path ip (opts.TryGetString(kPOVAttrib_InputFile, ""));
@@ -432,19 +432,19 @@ State SimpleFrontend<PARSER_MH, FILE_MH, RENDER_MH, IMAGE_MH>::GetState() const
 }
 
 template<class PARSER_MH, class FILE_MH, class RENDER_MH, class IMAGE_MH>
-shared_ptr<Console> SimpleFrontend<PARSER_MH, FILE_MH, RENDER_MH, IMAGE_MH>::GetConsole()
+boost::shared_ptr<Console> SimpleFrontend<PARSER_MH, FILE_MH, RENDER_MH, IMAGE_MH>::GetConsole()
 {
 	return renderFrontend.GetConsole(sceneId);
 }
 
 template<class PARSER_MH, class FILE_MH, class RENDER_MH, class IMAGE_MH>
-shared_ptr<Image> SimpleFrontend<PARSER_MH, FILE_MH, RENDER_MH, IMAGE_MH>::GetImage()
+boost::shared_ptr<Image> SimpleFrontend<PARSER_MH, FILE_MH, RENDER_MH, IMAGE_MH>::GetImage()
 {
 	return renderFrontend.GetImage(viewId);
 }
 
 template<class PARSER_MH, class FILE_MH, class RENDER_MH, class IMAGE_MH>
-shared_ptr<Display> SimpleFrontend<PARSER_MH, FILE_MH, RENDER_MH, IMAGE_MH>::GetDisplay()
+boost::shared_ptr<Display> SimpleFrontend<PARSER_MH, FILE_MH, RENDER_MH, IMAGE_MH>::GetDisplay()
 {
 	return renderFrontend.GetDisplay(viewId);
 }
diff --git a/vfe/unix/syspovconfig.h b/vfe/unix/syspovconfig.h
index 65d11ba..c665a62 100644
--- a/vfe/unix/syspovconfig.h
+++ b/vfe/unix/syspovconfig.h
@@ -81,7 +81,7 @@ using std::list;
 // to in a few other places.
 using std::runtime_error;
 
-// C++0x has a shared_ptr, but we currently use the boost one.
+// C++0x has a boost::shared_ptr, but we currently use the boost one.
 using boost::shared_ptr;
 
 #endif // STD_POV_TYPES_DECLARED
diff --git a/vfe/vfe.cpp b/vfe/vfe.cpp
index 93dc869..c2bf110 100644
--- a/vfe/vfe.cpp
+++ b/vfe/vfe.cpp
@@ -582,7 +582,7 @@ void vfeProcessRenderOptions::WriteError(const char *format, ...)
 //
 ////////////////////////////////////////////////////////////////////////////////////////
 
-VirtualFrontEnd::VirtualFrontEnd(vfeSession& session, POVMSContext ctx, POVMSAddress addr, POVMS_Object& msg, POVMS_Object *result, shared_ptr<Console>& console) :
+VirtualFrontEnd::VirtualFrontEnd(vfeSession& session, POVMSContext ctx, POVMSAddress addr, POVMS_Object& msg, POVMS_Object *result, boost::shared_ptr<Console>& console) :
   m_Session(&session), m_PlatformBase(session), renderFrontend (ctx)
 {
   backendAddress = addr ;
@@ -598,7 +598,7 @@ VirtualFrontEnd::~VirtualFrontEnd()
 {
   // file-backed images may require a reference to PlatformBase to delete temporary files
   // we need to explicitly delete it here since otherwise PlatformBase will have been destroyed
-  // before the shared_ptr does its cleanup
+  // before the boost::shared_ptr does its cleanup
   imageProcessing.reset();
   if (backendAddress != POVMSInvalidAddress)
     renderFrontend.DisconnectFromBackend(backendAddress);
@@ -689,7 +689,7 @@ bool VirtualFrontEnd::Start(POVMS_Object& opts)
 
     if (m_Session->OutputToFileSet())
     {
-      imageProcessing = shared_ptr<ImageProcessing> (new ImageProcessing (opts));
+      imageProcessing = boost::shared_ptr<ImageProcessing> (new ImageProcessing (opts));
       UCS2String filename = imageProcessing->GetOutputFilename (opts, 0, 0);
       options.SetUCS2String (kPOVAttrib_OutputFile, filename.c_str());
 
@@ -716,8 +716,8 @@ bool VirtualFrontEnd::Start(POVMS_Object& opts)
     opts.Set(kPOVAttrib_Declare, declares);
     imageProcessing.reset();
     if (m_Session->OutputToFileSet())
-      imageProcessing = shared_ptr<ImageProcessing> (new ImageProcessing (opts)) ;
-    animationProcessing = shared_ptr<AnimationProcessing> (new AnimationProcessing (opts)) ;
+      imageProcessing = boost::shared_ptr<ImageProcessing> (new ImageProcessing (opts)) ;
+    animationProcessing = boost::shared_ptr<AnimationProcessing> (new AnimationProcessing (opts)) ;
     options = animationProcessing->GetFrameRenderOptions () ;
   }
 
@@ -1125,7 +1125,7 @@ State VirtualFrontEnd::Process()
           }
 
           // now we display the render window, if enabled
-          shared_ptr<Display> display(GetDisplay());
+          boost::shared_ptr<Display> display(GetDisplay());
           if (display != NULL)
           {
             vfeDisplay *disp = dynamic_cast<vfeDisplay *>(display.get());
diff --git a/vfe/vfe.h b/vfe/vfe.h
index d4507d9..478901f 100644
--- a/vfe/vfe.h
+++ b/vfe/vfe.h
@@ -209,7 +209,7 @@ namespace vfe
   class VirtualFrontEnd
   {
     public:
-      VirtualFrontEnd(vfeSession& session, POVMSContext ctx, POVMSAddress addr, POVMS_Object& msg, POVMS_Object *result, shared_ptr<Console>& console) ;
+      VirtualFrontEnd(vfeSession& session, POVMSContext ctx, POVMSAddress addr, POVMS_Object& msg, POVMS_Object *result, boost::shared_ptr<Console>& console) ;
       virtual ~VirtualFrontEnd() ;
 
       virtual bool Start(POVMS_Object& opts) ;
@@ -240,9 +240,9 @@ namespace vfe
       POVMS_Object options;
       RenderFrontendBase::SceneId sceneId;
       RenderFrontendBase::ViewId viewId;
-      shared_ptr<AnimationProcessing> animationProcessing ;
-      shared_ptr<ImageProcessing> imageProcessing ;
-      shared_ptr<ShelloutProcessing> shelloutProcessing;
+      boost::shared_ptr<AnimationProcessing> animationProcessing ;
+      boost::shared_ptr<ImageProcessing> imageProcessing ;
+      boost::shared_ptr<ShelloutProcessing> shelloutProcessing;
       Console **consoleResult;
       Display **displayResult;
       vfeSession* m_Session;
diff --git a/vfe/vfesession.cpp b/vfe/vfesession.cpp
index ef10086..3c58f5e 100644
--- a/vfe/vfesession.cpp
+++ b/vfe/vfesession.cpp
@@ -543,7 +543,7 @@ const char *vfeSession::GetBackendStateName (void) const
 boost::shared_ptr<Display> vfeSession::GetDisplay() const
 {
   if (m_Frontend == NULL)
-    return (shared_ptr<Display>());
+    return (boost::shared_ptr<Display>());
   return m_Frontend->GetDisplay();
 }
 
@@ -581,7 +581,7 @@ void vfeSession::WorkerThread()
   m_BackendThread = povray_init (boost::bind(&vfeSession::BackendThreadNotify, this), const_cast<void **>(&pov::RenderThreadAddr)) ;
   POVMS_Output_Context = pov::POVMS_GUI_Context ;
 
-  m_Console = shared_ptr<vfeConsole> (new vfeConsole(this, m_ConsoleWidth)) ;
+  m_Console = boost::shared_ptr<vfeConsole> (new vfeConsole(this, m_ConsoleWidth)) ;
 
   POVMS_Object obj ;
   m_Frontend = new VirtualFrontEnd (*this, POVMS_Output_Context, (POVMSAddress) pov::RenderThreadAddr, obj, NULL, m_Console) ;
diff --git a/vfe/vfesession.h b/vfe/vfesession.h
index 56ec3fc..77d3979 100644
--- a/vfe/vfesession.h
+++ b/vfe/vfesession.h
@@ -1236,7 +1236,7 @@ namespace vfe
 
       static bool m_Initialized;
       static vfeSession *m_CurrentSessionTemporaryHack;
-      shared_ptr<Console> m_Console;
+      boost::shared_ptr<Console> m_Console;
 
       virtual vfeDisplay *DefaultDisplayCreator (unsigned int width, unsigned int height, GammaCurvePtr gamma, vfeSession *session, bool visible);
       DisplayCreator m_DisplayCreator;
diff --git a/vfe/win/syspovconfig.h b/vfe/win/syspovconfig.h
index 59d118d..8b4a281 100644
--- a/vfe/win/syspovconfig.h
+++ b/vfe/win/syspovconfig.h
@@ -78,7 +78,7 @@ using std::list;
 // to in a few other places.
 using std::runtime_error;
 
-// C++0x has a shared_ptr, but we currently use the boost one. alas, Visual Studio 2010
+// C++0x has a boost::shared_ptr, but we currently use the boost one. alas, Visual Studio 2010
 // pulls in the std::tr1::shared_ptr in some headers (particularly <memory>), and we thus
 // have to either specifically nominate boost::shared_ptr wherever we use it, or typedef
 // it. C++ doesn't [currently] support template typedefs but we could use the struct rebind
diff --git a/vfe/win/vfeplatform.cpp b/vfe/win/vfeplatform.cpp
index ea7a8bc..7ff6ffd 100644
--- a/vfe/win/vfeplatform.cpp
+++ b/vfe/win/vfeplatform.cpp
@@ -511,7 +511,7 @@ namespace vfePlatform
     startupInfo.dwFlags = pov_frontend::MinimizeShellouts() ? STARTF_USESHOWWINDOW : 0;
     startupInfo.wShowWindow = SW_SHOWMINNOACTIVE;
 
-    shared_ptr<char> buf(new char[params.size() + 1]);
+    boost::shared_ptr<char> buf(new char[params.size() + 1]);
     strcpy(buf.get(), params.c_str());
     if ((m_ProcessRunning = CreateProcess(cmd.c_str(), buf.get(), NULL, NULL, false, 0, NULL, NULL, &startupInfo, &procInfo)))
     {
diff --git a/windows/pvdisplay.cpp b/windows/pvdisplay.cpp
index a9080d4..fa6b671 100644
--- a/windows/pvdisplay.cpp
+++ b/windows/pvdisplay.cpp
@@ -101,7 +101,7 @@ namespace pov_frontend
 
 using namespace povwin;
 
-shared_ptr<Display> gDisplay;
+boost::shared_ptr<Display> gDisplay;
 
 BitmapInfo WinLegacyDisplay::m_BitmapTemplate;
 
diff --git a/windows/pvdisplay.h b/windows/pvdisplay.h
index d7e6c96..02be2a5 100644
--- a/windows/pvdisplay.h
+++ b/windows/pvdisplay.h
@@ -42,7 +42,7 @@ namespace pov_frontend
   using namespace vfe;
   using namespace povwin;
 
-  extern shared_ptr<Display> gDisplay;
+  extern boost::shared_ptr<Display> gDisplay;
 
   class WinDisplay : public vfeDisplay
   {
diff --git a/windows/pvengine.cpp b/windows/pvengine.cpp
index 7a16b54..80a771a 100644
--- a/windows/pvengine.cpp
+++ b/windows/pvengine.cpp
@@ -127,7 +127,7 @@ char *WriteDump(struct _EXCEPTION_POINTERS *pExceptionInfo, bool full, long time
 
 namespace pov_frontend
 {
-  extern shared_ptr<Display> gDisplay;
+  extern boost::shared_ptr<Display> gDisplay;
 }
 
 namespace vfePlatform
